<?xml version="1.0" encoding="utf-8"?>
<resources>
	<string-array name="smali_help_names">
		<item>Registros</item>
		<item>Valores literais</item>
		<item>Tipos de dados primitivos</item>
	</string-array>
	<string-array name="smali_help_values" formatted="false">
		<item>vA é um registrador de 4 bits com intervalo de valores v0 - v15\nvAA é um registrador de 8 bits com intervalo de valores de v0 - v255\nvAAAA é um registro de 16 bits com intervalo de valores de v0 - v65535</item>
		<item>0xF, 0xFF, etc. para representar valores literais. Assim como os registradores, o número F é usado para representar um intervalo de valores, por exemplo:\nO intervalo de valores 0xF é representado por [-0x8, 0x7]\nO intervalo de valores de 0xFF é representado por [-0x80, 0x7F]</item>
		<item>V - vazio, Z - booleano, B - byte\nC - char, S - curto, I - int\nJ - longo, F - flutuante, D - duplo\nvoid: só pode ser usado para tipos de retorno\nbooleano: armazena o valor verdadeiro ou falso\nbyte: armazena um número inteiro de -128 a 127 e ocupa 1 byte\ncurto: armazena um número inteiro de -32768 a 32767 e ocupa 2 bytes\nint: armazena um número inteiro de -2147483648 a 2147483647 e ocupa 4 bytes\nlong: armazena um número inteiro de -9223372036854775808 a 9223372036854775807 e ocupa 8 bytes\ndouble: armazena um número de ponto flutuante de ±4,9*10³²⁴ a ±1,7976931348623157*10³⁰⁸ e ocupa 8 bytes. Um ponto é usado como separador decimal em literais fracionários.\nfloat: armazena um número de ponto flutuante de -3,4*10³⁸ a 3,4*10³⁸ e ocupa 4 bytes\nchar: armazena um único caractere na codificação UTF-16 e ocupa 2 bytes, portanto o intervalo de valores armazenados é de 0 a 65535.</item>
		<item>Nenhuma ação.</item>
		<item>Move o valor do registrador vB para o registrador vA.</item>
		<item>Move o valor do registro vBBBB para o registro vAA.</item>
		<item>Move o valor do registro vBBBB para o registro vAAAA.</item>
		<item>Move o valor longo/duplo do par de registros (vB, vB+1) para o par de registros vA, vA+1.</item>
		<item>Move o valor longo/duplo de um par de registros (vBBBB, vBBBB+1) para um par de registros vAA, vAA+1.</item>
		<item>Move o valor longo/duplo de um par de registros (vBBBB, vBBBB+1) para um par de registros vAAAA, vAAAA+1.</item>
		<item>Move uma referência de objeto do registro vB para o registro vA.</item>
		<item>Move uma referência de objeto do registro vBBBB para o registro vAA.</item>
		<item>Move uma referência de objeto do registro vBBBB para o registro vAAAA.</item>
		<item>Move o valor de retorno do método chamado anteriormente para o registro vAA.</item>
		<item>Move o valor long/double retornado pelo método chamado anteriormente para o par de registradores vAA, vAA+1.</item>
		<item>Move a referência do objeto retornada pelo método chamado anteriormente para o registro vAA.</item>
		<item>Move a referência ao objeto excluído emitido durante a chamada do método (durante a execução) para o registro vAA.</item>
		<item>Retorno sem valor de retorno.</item>
		<item>Retorne retornando o valor do registro vAA.</item>
		<item>Retorne retornando um valor duplo/longo em um par de registradores vAA, vAA+1.</item>
		<item>Retorne retornando o valor da referência do objeto do registro vAA.</item>
		<item>Coloca uma constante de 4 bits no registro vA.</item>
		<item>Coloca uma constante de 16 bits no registro vAA.</item>
		<item>Coloca uma constante inteira no registro vAA.</item>
		<item>Coloca uma constante de 16 bits nos bits superiores do registro vAA. Usado para inicializar valores flutuantes (ponto flutuante).</item>
		<item>Coloca uma constante inteira de 16 bits no par de registradores vAA, vAA+1, convertendo a constante inteira em uma constante longa.</item>
		<item>Coloca uma constante inteira de 32 bits no par de registradores vAA, vAA+1, convertendo a constante inteira em uma constante longa.</item>
		<item>Coloca uma constante de 64 bits no par de registradores vAA, vAA+1.</item>
		<item>Coloca uma constante de 16 bits nos 16 bits superiores do par de registradores vAA, vAA+1. Usado para inicializar valores duplos (ponto flutuante).</item>
		<item>Coloca uma referência à string especificada no registro vAA.</item>
		<item>Coloca uma referência à string especificada no registro vAA.</item>
		<item>Coloca uma referência à constante de string (string) identificada por string_id no registro vAA.</item>
		<item>Obtém o monitor de objeto referenciado pelo registro vAA.</item>
		<item>Libera o monitor de objeto referenciado pelo registro vAA.</item>
		<item>Verifica se uma referência de objeto contida no registro vAA pode ser convertida para a classe identificada por type_id. Lança uma ClassCastException se não puder, caso contrário, continua a execução.</item>
		<item>Verifica se o conteúdo do registrador vB é uma instância da classe identificada por type_id. Define o registro vA como diferente de zero, se presente, e 0, se não.\nvA = vB instância do tipo? 10</item>
		<item>Determina o número de elementos da matriz do registro vB e coloca o valor no registro vA.\nvA = vB.comprimento</item>
		<item>Cria uma instância de um tipo de objeto e coloca uma referência à instância criada no registro vAA.</item>
		<item>Cria um novo array de variáveis type_id com o tamanho dos elementos do registro vB e coloca uma referência ao array no registro vA.</item>
		<item>Cria uma nova matriz de dados do tipo type_id e a preenche com parâmetros (ou seja, nenhuma matriz longa/dupla, mas tipos de referência são permitidos). Uma referência ao array recém-criado pode ser obtida usando a instrução move-result-object imediatamente após esta instrução (se alguma for usada).</item>
		<item>Cria uma nova matriz de dados do tipo type_id e a preenche com um intervalo de parâmetros (ou seja, nenhuma matriz longa/dupla, mas tipos de referência são aceitáveis). Uma referência ao array recém-criado pode ser obtida usando a instrução move-result-object imediatamente após esta instrução (se alguma for usada).</item>
		<item>Preenche a matriz referenciada no registro vAA com dados estáticos. A localização dos dados é a soma da posição da instrução atual e do deslocamento.</item>
		<item>Lança um objeto de exceção. Uma referência ao objeto de exceção no registro vAA.</item>
		<item>Salte incondicionalmente para um deslocamento curto (inteiro) de 8 bits.</item>
		<item>Salto incondicional para deslocamento de 16 bits.</item>
		<item>Salto incondicional para deslocamento de 32 bits.</item>
		<item>Implementa o operador Switch quando as constantes de controle estão próximas umas das outras (em uma linha). A instrução usa uma tabela de índice. O deslocamento da instrução para um caso específico é determinado pelo índice vAA. Se o índice vAA ultrapassar a tabela, a execução continua com a próxima instrução (padrão).</item>
		<item>Implementa o operador Switch no caso de uma tabela esparsa. A instrução usa uma tabela que especifica deslocamentos para cada constante. Se nenhuma correspondência for encontrada na tabela, a próxima instrução será executada (caso padrão).</item>
		<item>Compara os valores float (ponto flutuante) em vBB e vCC e coloca o valor inteiro no registro vAA:\nvAA = vBB &lt;vCC ? sim: 1, não: -1, igual: 0</item>
		<item>Compara os valores float (ponto flutuante) em vBB e vCC e coloca o valor inteiro no registro vAA:\nvAA = vBB &lt;vCC ? sim: 1, não: -1, igual: 0</item>
		<item>Compara os valores duplos (ponto flutuante) em vBB e vCC e coloca o valor inteiro no registro vAA:\nvAA = (vBB, vBB+1) &lt; (vCC, vCC+1) ? sim\nsim: 1, não: -1, igual: 0</item>
		<item>Compara os valores duplos (ponto flutuante) em vBB e vCC e coloca o valor inteiro no registro vAA:\nvAA = (vBB, vBB+1) > (vCC, vCC+1) ? sim: 1, não: -1, igual: 0</item>
		<item>Compara os valores longos (inteiros) em vBB e vCC e coloca o valor inteiro (inteiro) no registro vAA:\nvAA = (vBB, vBB+1) > (vCC, vCC+1) ? sim: 1, não: -1, igual: 0</item>
		<item>Salta para o rótulo especificado se vA == vB. vA e vB contêm valores inteiros.\n(eq é a abreviação de Igual a)</item>
		<item>Salta para o rótulo especificado se vA != vB. vA e vB contêm valores inteiros.\n(ne é a abreviação de Not Equals)</item>
		<item>Salta para o rótulo especificado se vA &lt; vB. vA e vB contêm valores inteiros.\n(é a abreviação de Menos que)</item>
		<item>Salta para o rótulo especificado se vA &lt;= vB. vA e vB contêm valores inteiros.\n(le é uma abreviatura de Menor que ou Igual/Menos ou igual)</item>
		<item>Salta para o rótulo especificado se vA > vB. vA e vB contêm valores inteiros.\n(gt é a abreviação de Maior que/Mais que)</item>
		<item>Salta para o rótulo especificado se vA >= vB. vA e vB contêm valores inteiros.\n(ge é a abreviação de Maior que ou Igual)</item>
		<item>Salta para o rótulo especificado se vAA == 0. vAA contém um valor inteiro.\n(eqz é a abreviação de Igual a Zero)</item>
		<item>Salta para o rótulo especificado se vAA != 0. vAA contém um valor inteiro.\n(nez é a abreviatura de Diferente de Zero)</item>
		<item>Salta para o rótulo especificado se vAA &lt; 0. vAA contém um valor inteiro.\n(ltz é a abreviação de Menos que Zero)</item>
		<item>Salta para o rótulo especificado se vAA &lt;= 0. vAA contém um valor inteiro.\n(lez é uma abreviatura de Menor ou Igual a Zero/Menos ou igual a zero)</item>
		<item>Salta para o rótulo especificado se vAA > 0. vAA contém um valor inteiro.\n(gtz é a abreviação de Maior que Zero)</item>
		<item>Salta para o rótulo especificado se vAA >= 0. vAA contém um valor inteiro.\n(gez é uma abreviatura de Maior ou Igual a Zero)</item>
		<item>Obtém um valor inteiro no índice contido em vCC do array referenciado em vBB e o coloca no registro vAA.\nvAA = vBB[vCC]</item>
		<item>Obtém, no índice contido em vCC, do array referenciado em vBB, um valor duplo/longo e o coloca no par de registradores vAA, vAA+1.\n(vAA, vAA+1) = vBB[vCC]</item>
		<item>Recebe, no índice contido em vCC, do array referenciado em vBB, uma referência ao objeto e a coloca no registrador vAA.\nvAA = vBB[vCC]</item>
		<item>Obtém, no índice contido em vCC, do array referenciado em vBB, um valor booleano e o coloca no registrador vAA.\nvAA = vBB[vCC]</item>
		<item>Recupera, no índice contido em vCC, do array referenciado em vBB, um valor de byte (inteiro) e o coloca no registrador vAA.\nvAA = vBB[vCC]</item>
		<item>Recupera, no índice contido em vCC, do array referenciado em vBB, um valor char e o coloca no registro vAA.\nvAA = vBB[vCC]</item>
		<item>Recupera, no índice contido em vCC, do array referenciado em vBB, um valor curto (inteiro) e o coloca no registro vAA.\nvAA = vBB[vCC]</item>
		<item>Coloca o valor inteiro de vAA na matriz referenciada em vBB com o elemento que contém o registro vCC.\nvBB[vCC] = vAA</item>
		<item>Coloca um valor duplo/longo do par de registros vAA, vAA+1 na matriz referenciada em vBB, com o elemento contendo o registro vCC.\nvBB[vCC] = (vAA, vAA+1)</item>
		<item>Coloca uma referência a um objeto de vAA na matriz referenciada em vBB com um elemento com o registro vCC.\nvBB[vCC] = vAA</item>
		<item>Coloca o valor booleano de vAA na matriz referenciada por vBB com o elemento que contém o registro vCC.\nvBB[vCC] = vAA</item>
		<item>Coloca o valor do byte (inteiro) de vAA na matriz referenciada em vBB com o elemento que contém o registro vCC.\nvBB[vCC] = vAA</item>
		<item>Coloca o valor char (caractere) de vAA no array referenciado em vBB por elemento com registro vCC.\nvBB[vCC] = vAA</item>
		<item>Coloca o valor curto (inteiro) de vAA na matriz referenciada em vBB com o elemento que contém o registro vCC.\nvBB[vCC] = vAA</item>
		<item>Lê o valor do campo de instância e o coloca no registro vA. A referência à classe que contém este campo está no registro vB.\nvA = vB.campo</item>
		<item>Lê um valor duplo/longo de um campo de instância e o coloca em um par de registradores (vA, vA+1). A referência à classe que contém este campo está no registro vB.\n(vA, vA+1) = vB.campo</item>
		<item>Lê uma referência de objeto de um campo de instância e a coloca no registro vA. A referência à classe que contém este campo está no registro vB.\nvA = vB.campo</item>
		<item>Lê um valor booleano do campo de instância e o coloca no registro vA. A referência à classe que contém este campo está no registro vB.\nvA = vB.campo</item>
		<item>Lê um valor de byte (inteiro) de um campo de instância e o coloca no registro vA. A referência à classe que contém este campo está no registro vB.\nvA = vB.campo</item>
		<item>Lê um valor char de um campo de instância e o coloca no registro vA. A referência à classe que contém este campo está no registro vB.\nvA = vB.campo</item>
		<item>Lê um valor curto (inteiro) de um campo de instância e o coloca no registro vA. A referência à classe que contém este campo está no registro vB.\nvA = vB.campo</item>
		<item>Coloca o valor do registro vA no campo de instância. A referência à classe que contém este campo está no registro vB.\nvB.campo = vA</item>
		<item>Coloca um valor duplo/longo de um par de registros (vA, vA+1) em um campo de instância. A referência à classe que contém este campo está no registro vB.\nvB.campo = (vA, vA+1)</item>
		<item>Coloca uma referência a um objeto do registro vA no campo de instância. A referência à classe que contém este campo está no registro vB.\nvB.campo = vA</item>
		<item>Coloca o valor booleano do registro vA no campo de instância. A referência à classe que contém este campo está no registro vB.\nvB.campo = vA</item>
		<item>Define o valor do byte (inteiro) do campo booleano especificado na instância referenciada pelo registro vB igual ao valor do registro vA, ou seja:\nvB.campo = vA</item>
		<item>Define o valor char (caractere) do campo booleano especificado na instância referenciada pelo registro vB igual ao valor do registro vA, ou seja:\nvB.campo = vA</item>
		<item>Define o valor curto (inteiro) do campo booleano especificado na instância referenciada pelo registro vB igual ao valor do registro vA, ou seja:\nvB.campo = vA</item>
		<item>Lê um valor de um campo estático e o coloca no registro vAA. O registro que contém a referência à classe que contém este campo não é utilizado.</item>
		<item>Lê um valor duplo/longo de um campo estático e o coloca em um par de registradores vAA, vAA+1. O registro que contém a referência à classe que contém este campo não é utilizado.</item>
		<item>Lê uma referência de objeto de um campo estático e a coloca no registro vAA. O registro que contém a referência à classe que contém este campo não é utilizado.</item>
		<item>Lê um valor booleano de um campo estático e o coloca no registro vAA. O registro que contém a referência à classe que contém este campo não é utilizado.</item>
		<item>Lê um valor de byte (inteiro) de um campo estático e o coloca no registro vAA. O registro que contém a referência à classe que contém este campo não é utilizado.</item>
		<item>Lê um valor char de um campo estático e o coloca no registro vAA. O registro que contém a referência à classe que contém este campo não é utilizado.</item>
		<item>Lê um valor curto (inteiro) de um campo estático e o coloca no registro vAA. O registro que contém a referência à classe que contém este campo não é utilizado.</item>
		<item>Coloca o valor do registro vAA em um campo (campo estático). O registro que contém a referência à classe que contém este campo não é utilizado.</item>
		<item>Coloca um valor duplo/longo de um par de registradores vAA, vAA+1 em um campo (campo estático). O registro que contém a referência à classe que contém este campo não é utilizado.</item>
		<item>Coloca uma referência a um objeto do registro vAA em um campo (campo estático). O registro que contém a referência à classe que contém este campo não é utilizado.</item>
		<item>Coloca o valor booleano do registro vAA em um campo (campo estático). O registro que contém a referência à classe que contém este campo não é utilizado.</item>
		<item>Coloca um valor de byte (inteiro) do registro vAA em um campo (campo estático). O registro que contém a referência à classe que contém este campo não é utilizado.</item>
		<item>Coloca o valor char do registro vAA em um campo estático. O registro que contém a referência à classe que contém este campo não é utilizado.</item>
		<item>Coloca o valor curto (inteiro) do registro vAA em um campo estático. O registro que contém a referência à classe que contém este campo não é utilizado.</item>
		<item>Chama (executa) um método virtual com parâmetros. Os parâmetros são indicados entre chaves. O primeiro parâmetro (registro v2) contém uma referência à classe que contém o método chamado, o segundo parâmetro (o conteúdo do registro v3) é passado para o método chamado.</item>
		<item>Chama (executa) um método virtual com parâmetros diretamente da classe pai.</item>
		<item>Chama (executa) um método com parâmetros sem as permissões do método virtual.</item>
		<item>Chama (executa) um método estático com parâmetros. Os parâmetros são indicados entre chaves. O parâmetro (o conteúdo do registrador v3) é passado para o método chamado. A classe que contém o método chamado é indicada após as chaves.</item>
		<item>Chama (executa) um método de interface com parâmetros.</item>
		<item>Chama (executa) um método virtual com parâmetros, mas os parâmetros devem estar contidos em registradores com números em ordem.</item>
		<item>Chama (executa) um método virtual com parâmetros diretamente da classe pai, mas os parâmetros devem estar contidos em registradores com números sequenciais.</item>
		<item>Chama (executa) um método com parâmetros sem permissões de método virtual, mas os parâmetros devem estar contidos em registros numerados sequencialmente.</item>
		<item>Chama (executa) um método estático com parâmetros, mas os parâmetros devem estar contidos em registradores com números sequenciais.</item>
		<item>Chama (executa) um método de interface com parâmetros, mas os parâmetros devem estar contidos em registradores numerados sequencialmente.</item>
		<item>Calcula vA = -vB para valores do tipo inteiro.</item>
		<item>Calcula vA = ~vB para valores inteiros.\nvA = ~vB</item>
		<item>Calcula (vA, vA+1) = -(vB, vB+1) para valores do tipo long (inteiro).</item>
		<item>Calcula (vA, vA+1) = ~(vB, vB+1) para valores do tipo long (inteiro).</item>
		<item>Calcula vA = -vB para valores flutuantes.</item>
		<item>Calcula (vA, vA+1) = -(vB, vB+1) para valores duplos (ponto flutuante).</item>
		<item>Converte um número inteiro de vB em um longo e o armazena no par de registros vA, vA+1.\n(vA, vA+1) = (longo) vB</item>
		<item>Converte um número inteiro de vB em float e o armazena no registro vA.\nvA = (flutuante) vB</item>
		<item>Converte um número inteiro de vB em um duplo (ponto flutuante) e o armazena em um par de registros vA, vA+1.\n(vA, vA+1) = (duplo) vB</item>
		<item>Converte um valor longo (inteiro) de vB, vB+1 em um número inteiro (inteiro) e o armazena no registro vA.\nvA = (int) (vB, vB+1)</item>
		<item>Converte um valor longo (inteiro) de vB, vB+1 em um float (ponto flutuante) e o armazena no registro vA.\nvA = (flutuante) (vB, vB+1)</item>
		<item>Converte um valor longo (inteiro) de vB, vB+1 em um valor duplo (ponto flutuante) e o armazena em um par de registros vA, vA+1.\n(vA, vA+1) = (duplo) (vB, vB+1)</item>
		<item>Converte um valor float (ponto flutuante) de vB em um valor inteiro (inteiro) e o armazena no registro vA.\nvA = (int)vB</item>
		<item>Converte um valor float (ponto flutuante) de vB em um valor longo (inteiro) e o armazena no par de registros vA, vA+1.\n(vA, vA+1) = (longo) vB</item>
		<item>Converte um valor float (ponto flutuante) de vB em um valor duplo (ponto flutuante) e o armazena no par de registros vA, vA+1.\n(vA, vA+1) = (duplo) vB</item>
		<item>Converte um valor duplo (ponto flutuante) de vB, vB+1 em um valor inteiro (inteiro) e o armazena no registro vA.\nvA = (int) (vB, vB+1)</item>
		<item>Converte um valor duplo (ponto flutuante) de vB, vB+1 em um valor longo (inteiro) e o armazena em um par de registros vA, vA+1.\n(vA, vA+1) = (longo) (vB, vB+1)</item>
		<item>Converte um valor duplo (ponto flutuante) de vB, vB+1 em um valor flutuante (ponto flutuante) e o armazena no registro vA.\nvA = (flutuante) (vB, vB+1)</item>
		<item>Converte um valor inteiro de vB em um valor de byte e o armazena no registro vA.\nvA = (byte) vB</item>
		<item>Converte um valor inteiro de vB em um valor char e o armazena no registro vA.\nvA = (caractere)vB</item>
		<item>Converte um valor inteiro de vB em um valor curto e o armazena no registro vA.\nvA = (curto) vB</item>
		<item>Calcula vBB + vCC e armazena o resultado no registrador vAA. Todos os valores são inteiros.\nvAA = vBB + vCC</item>
		<item>Calcula vBB - vCC e armazena o resultado no registrador vAA. Todos os valores são inteiros.\nvAA = vBB - vCC</item>
		<item>Calcula vBB * vCC e armazena o resultado no registrador vAA. Todos os valores são inteiros.\nvAA = vBB * vCC</item>
		<item>Calcula vBB/vCC e armazena o resultado no registrador vAA. Todos os valores são inteiros.\nvAA = vBB /vCC</item>
		<item>Calcula vBB % vCC e armazena o resultado no registro vAA. Todos os valores são inteiros.\nvAA = vBB % vCC</item>
		<item>Calcula vBB e vCC (AND lógico) e armazena o resultado no registro vAA. Todos os valores são inteiros.\nvAA = vBB e vCC</item>
		<item>Calcula vBB | vCC (OU lógico) e armazena o resultado no registro vAA. Todos os valores são inteiros.\nvAA = vBB | vCC</item>
		<item>Calcula vBB ^ vCC (OR exclusivo) e armazena o resultado no registro vAA. Todos os valores são inteiros.\nvAA = vBB ^ vCC</item>
		<item>Desloca vBB para a esquerda pelo número de bits especificado por vCC e armazena o resultado no registrador vAA. Todos os valores são inteiros.\nvAA = vBB &lt;&lt; vCC</item>
		<item>Desloca vBB para a direita pelo número de bits especificado por vCC e armazena o resultado no registrador vAA. Todos os valores são inteiros.\nvAA = vBB >> vCC</item>
		<item>Desloca vBB sem preservar o sinal para a direita pelo número de bits especificado por vCC e armazena o resultado no registrador vAA. Todos os valores são inteiros.\nvAA = vBB >>> vCC</item>
		<item>Calcula (vBB, vBB+1) + (vCC, vCC+1) e armazena o resultado no par de registradores vAA, vAA+1. Todos os valores são longos (inteiros).\n(vAA, vAA+1) = (vBB, vBB+1) + (vCC, vCC+1)</item>
		<item>Calcula (vBB, vBB+1) - (vCC, vCC+1) e armazena o resultado no par de registradores vAA, vAA+1. Todos os valores são longos (inteiros).\n(vAA, vAA+1) = (vBB, vBB+1) - (vCC, vCC+1)</item>
		<item>Calcula (vBB, vBB+1) * (vCC, vCC+1) e armazena o resultado no par de registradores vAA, vAA+1. Todos os valores são longos (inteiros).\n(vAA, vAA+1) = (vBB, vBB+1) * (vCC, vCC+1)</item>
		<item>Calcula (vBB, vBB+1) / (vCC, vCC+1) e armazena o resultado no par de registradores vAA, vAA+1. Todos os valores são longos (inteiros).\n(vAA, vAA+1) = (vBB, vBB+1) / (vCC, vCC+1)</item>
		<item>Calcula (vBB, vBB+1) % (vCC, vCC+1) e armazena o resultado no par de registradores vAA, vAA+1. Todos os valores são longos (inteiros).\n(vAA, vAA+1) = (vBB, vBB+1) % (vCC, vCC+1)</item>
		<item>Calcula (vBB, vBB+1) &amp; (vCC, vCC+1) (AND lógico) e armazena o resultado no par de registradores vAA, vAA+1. Todos os valores são longos (inteiros).\n(vAA, vAA+1) = (vBB, vBB+1) e (vCC, vCC+1)</item>
		<item>Cálculos (vBB, vBB+1) | (vCC, vCC+1) (OR lógico) e armazena o resultado em um par de registradores vAA, vAA+1. Todos os valores são longos (inteiros).\n(vAA, vAA+1) = (vBB, vBB+1) | (vCC, vCC+1)</item>
		<item>Calcula (vBB, vBB+1) ^ (vCC, vCC+1) (AND exclusivo) e armazena o resultado no par de registradores vAA, vAA+1. Todos os valores são longos (inteiros).\n(vAA, vAA+1) = (vBB, vBB+1) ^ (vCC, vCC+1)</item>
		<item>Desloca vBB, vBB+1 para a esquerda pelo número de bits especificado por vCC e armazena o resultado no par de registradores vAA, vAA+1. Todos os valores são longos (inteiros).\n(vAA, vAA+1) = (vBB, vBB+1) &lt;&lt; vCC</item>
		<item>Desloca vBB, vBB+1 para a direita pelo número de bits especificado por vCC e armazena o resultado no par de registradores vAA, vAA+1. Todos os valores são longos (inteiros).\n(vAA, vAA+1) = (vBB, vBB+1) >> vCC</item>
		<item>Desloca vBB, vBB+1 para a direita sem preservar o sinal pelo número de bits especificado por vCC e armazena o resultado em um par de registradores vAA, vA+1. Todos os valores são longos (inteiros).\n(vAA, vAA+1) = (vBB, vBB+1) >>> vCC</item>
		<item>Calcula vBB + vCC e armazena o resultado no registrador vAA. Todos os valores são flutuantes.\nvAA = vBB + vCC</item>
		<item>Calcula vBB - vCC e armazena o resultado no registrador vAA. Todos os valores são flutuantes.\nvAA = vBB - vCC</item>
		<item>Calcula vBB * vCC e armazena o resultado no registrador vAA. Todos os valores são flutuantes.\nvAA = vBB * vCC</item>
		<item>Calcula vBB/vCC e armazena o resultado no registrador vAA. Todos os valores são flutuantes.\nvAA = vBB /vCC</item>
		<item>Calcula vBB % vCC e armazena o resultado no registro vAA. Todos os valores são flutuantes.\nvAA = vBB % vCC</item>
		<item>Calcula (vBB, vBB+1) + (vCC, vCC+1) e armazena o resultado no par de registradores vAA, vAA+1. Todos os valores são duplos (ponto flutuante).\n(vAA, vAA+1) = (vBB, vBB+1) + (vCC, vCC+1)</item>
		<item>Calcula (vBB, vBB+1) - (vCC, vCC+1) e armazena o resultado no par de registradores vAA, vAA+1. Todos os valores são duplos (ponto flutuante).\n(vAA, vAA+1) = (vBB, vBB+1) - (vCC, vCC+1)</item>
		<item>Calcula (vBB, vBB+1) * (vCC, vCC+1) e armazena o resultado no par de registradores vAA, vAA+1. Todos os valores são duplos (ponto flutuante).\n(vAA, vAA+1) = (vBB, vBB+1) * (vCC, vCC+1)</item>
		<item>Calcula (vBB, vBB+1) / (vCC, vCC+1) e armazena o resultado no par de registradores vAA, vAA+1. Todos os valores são duplos (ponto flutuante).\n(vAA, vAA+1) = (vBB, vBB+1) / (vCC, vCC+1)</item>
		<item>Calcula (vBB, vBB+1) % (vCC, vCC+1) e armazena o resultado no par de registradores vAA, vAA+1. Todos os valores são duplos (ponto flutuante).\n(vAA, vAA+1) = (vBB, vBB+1) % (vCC, vCC+1)</item>
		<item>Calcula vA + vB e armazena o resultado no registrador vA. Todos os valores são inteiros.\nvA = vA + vB</item>
		<item>Calcula vA - vB e armazena o resultado no registrador vA. Todos os valores são inteiros.\nvA = vA - vB</item>
		<item>Calcula vA * vB e armazena o resultado no registrador vA. Todos os valores são inteiros.\nvA = vA * vB</item>
		<item>Calcula vA/vB e armazena o resultado no registrador vA. Todos os valores são inteiros.\nvA = vA / vB</item>
		<item>Calcula vA % vB e armazena o resultado no registrador vA. Todos os valores são inteiros.\nvA = vA % vB</item>
		<item>Calcula vA e vB (AND lógico) e armazena o resultado no registrador vA. Todos os valores são inteiros.\nvA = vA e vB</item>
		<item>Calcula vA | vB (OR lógico) e armazena o resultado no registrador vA. Todos os valores são inteiros.\nvA = vA | vB</item>
		<item>Calcula vA ^ vB (OR exclusivo) e armazena o resultado no registrador vA. Todos os valores são inteiros.\nvA = vA ^ vB</item>
		<item>Desloca vA para a esquerda pelo número de bits especificado por vB e armazena o resultado no registrador vA. Todos os valores são inteiros.\nvA = vA &lt;&lt; vB</item>
		<item>Desloca vA para a direita pelo número de bits especificado por vB e armazena o resultado no registrador vA. Todos os valores são inteiros.\nvA = vA >> vB</item>
		<item>Desloca vA sem preservar seu sinal para a direita pelo número de bits especificado por vB e armazena o resultado no registrador vA. Todos os valores são inteiros.\nvA = vA >>> vB</item>
		<item>Calcula (vA, vA+1) + (vB, vB+1) e armazena o resultado no par de registradores vA, vA+1. Todos os valores são longos (inteiros).\n(vA, vA+1) = (vA, vA+1) + (vB, vB+1)</item>
		<item>Calcula (vA, vA+1) - (vB, vB+1) e armazena o resultado em um par de registradores vA, vA+1. Todos os valores são longos (inteiros).\n(vA, vA+1) = (vA, vA+1) - (vB, vB+1)</item>
		<item>Calcula (vA, vA+1) * (vB, vB+1) e armazena o resultado no par de registradores vA, vA+1. Todos os valores são longos (inteiros).\n(vA, vA+1) = (vA, vA+1) * (vB, vB+1)</item>
		<item>Calcula (vA, vA+1) / (vB, vB+1) e armazena o resultado no par de registradores vA, vA+1. Todos os valores são longos (inteiros).\n(vA, vA+1) = (vA, vA+1) / (vB, vB+1)</item>
		<item>Calcula (vA, vA+1) % (vB, vB+1) e armazena o resultado no par de registradores vA, vA+1. Todos os valores são longos (inteiros).\n(vA, vA+1) = (vA, vA+1)% (vB, vB+1)</item>
		<item>Calcula (vA, vA+1) &amp; (vB, vB+1) (AND lógico) e armazena o resultado no par de registradores vA, vA+1. Todos os valores são longos (inteiros).\n(vA, vA+1) = (vA, vA+1) e (vB, vB+1)</item>
		<item>Calcula (vA, vA+1) | (vB, vB+1) (OU lógico) e armazena o resultado em um par de registradores vA, vA+1. Todos os valores são longos (inteiros).\n(vA, vA+1) = (vA, vA+1) | (vB, vB+1)</item>
		<item>Calcula (vA, vA+1) &amp; (vB, vB+1) (OU exclusivo) e armazena o resultado no par de registros vA, vA+1. Todos os valores são longos (inteiros).\n(vA, vA+1) = (vA, vA+1) ^ (vB, vB+1)</item>
		<item>Desloca vA, vA+1 para a esquerda pelo número de bits especificado por vB e armazena o resultado no par de registradores vA, vA+1. Todos os valores são longos (inteiros).\n(vA, vA+1) = (vA, vA+1) &lt;&lt; vB</item>
		<item>Desloca vA, vA+1 para a direita pelo número de bits especificado por vB e armazena o resultado no par de registradores vA, vA+1. Todos os valores são longos (inteiros).\n(vA, vA+1) = (vA, vA+1) >> vB</item>
		<item>Desloca vA, vA+1 para a direita sem preservar o sinal pelo número de dígitos especificado por vB e armazena o resultado em um par de registradores vA, vA+1. Todos os valores são longos (inteiros).\n(vA, vA+1) = (vA, vA+1) >>> vB</item>
		<item>Calcula vA + vB e armazena o resultado no registrador vA. Todos os valores são flutuantes.\nvA = vA + vB</item>
		<item>Calcula vA - vB e armazena o resultado no registrador vA. Todos os valores são flutuantes.\nvA = vA - vB</item>
		<item>Calcula vA * vB e armazena o resultado no registrador vA. Todos os valores são flutuantes.\nvA = vA * vB</item>
		<item>Calcula vA/vB e armazena o resultado no registrador vA. Todos os valores são flutuantes.\nvA = vA / vB</item>
		<item>Calcula vA % vB e armazena o resultado no registrador vA. Todos os valores são flutuantes.\nvA = vA % vB</item>
		<item>Calcula (vA, vA+1) + (vB, vB+1) e armazena o resultado no par de registradores vA, vA+1. Todos os valores são duplos (ponto flutuante).\n(vA, vA+1) = (vA, vA+1) + (vB, vB+1)</item>
		<item>Calcula (vA, vA+1) - (vB, vB+1) e armazena o resultado em um par de registradores vA, vA+1. Todos os valores são duplos (ponto flutuante).\n(vA, vA+1) = (vA, vA+1) - (vB, vB+1)</item>
		<item>Calcula (vA, vA+1) * (vB, vB+1) e armazena o resultado no par de registradores vA, vA+1. Todos os valores são duplos (ponto flutuante).\n(vA, vA+1) = (vA, vA+1) * (vB, vB+1)</item>
		<item>Calcula (vA, vA+1) / (vB, vB+1) e armazena o resultado no par de registradores vA, vA+1. Todos os valores são duplos (ponto flutuante).\n(vA, vA+1) = (vA, vA+1) / (vB, vB+1)</item>
		<item>Calcula (vA, vA+1) % (vB, vB+1) e armazena o resultado no par de registradores vA, vA+1. Todos os valores são duplos (ponto flutuante).\n(vA, vA+1) = (vA, vA+1)% (vB, vB+1)</item>
		<item>Calcula vB + 0xFFFF e armazena o resultado no registrador vA. Todos os valores são inteiros.\nvA = vB + 0xFFFF</item>
		<item>Calcula 0xFFFF - vB e armazena o resultado no registro vA. Todos os valores são inteiros.\nvA = 0xFFFF - vB</item>
		<item>Calcula vB * 0xFFFF e armazena o resultado no registrador vA. Todos os valores são inteiros.\nvA = vB * 0xFFFF</item>
		<item>Calcula vB/0xFFFF e armazena o resultado no registrador vA. Todos os valores são inteiros.\nvA = vB / 0xFFFF</item>
		<item>Calcula vB % 0xFFFF e armazena o resultado no registrador vA. Todos os valores são inteiros.\nvA = vB% 0xFFFF</item>
		<item>Calcula vB &amp; 0xFFFF (AND lógico) e armazena o resultado no registro vA. Todos os valores são inteiros.\nvA = vB &amp; 0xFFFF</item>
		<item>Calcula vB | 0xFFFF (OR lógico) e armazena o resultado no registrador vA. Todos os valores são inteiros.\nvA = vB | 0xFFFF</item>
		<item>Calcula vB ^ 0xFFFF (OR exclusivo) e armazena o resultado no registro vA. Todos os valores são inteiros.\nvA = vB ^ 0xFFFF</item>
		<item>Calcula vBB + 0xFF e armazena o resultado no registrador vAA. Todos os valores são inteiros.\nvAA = vBB + 0xFF</item>
		<item>Calcula 0xFF - vBB e armazena o resultado no registrador vAA. Todos os valores são inteiros.\nvAA = 0xFF - vBB</item>
		<item>Calcula vBB * 0xFF e armazena o resultado no registro vAA. Todos os valores são inteiros.\nvAA = vBB * 0xFF</item>
		<item>Calcula vBB/0xFF e armazena o resultado no registrador vAA. Todos os valores são inteiros.\nvAA = vBB/0xFF</item>
		<item>Calcula vBB % 0xFF e armazena o resultado no registro vAA. Todos os valores são inteiros.\nvAA = vBB% 0xFF</item>
		<item>Calcula vBB e 0xFF (AND lógico) e armazena o resultado no registro vAA. Todos os valores são inteiros.\nvAA = vBB e 0xFF</item>
		<item>Calcula vBB | 0xFF (OR lógico) e armazena o resultado no registro vAA. Todos os valores são inteiros.\nvAA = vBB | 0xFF</item>
		<item>Calcula vBB ^ 0xFF (OR exclusivo) e armazena o resultado no registro vAA. Todos os valores são inteiros.\nvAA = vBB ^ 0xFF</item>
		<item>Desloca vBB para a esquerda pelo número de bits especificado por 0xFF e armazena o resultado no registrador vAA. Todos os valores são inteiros.\nvAA = vBB &lt;&lt; 0xFF</item>
		<item>Desloca vBB para a direita pelo número de bits especificado por 0xFF e armazena o resultado no registrador vAA. Todos os valores são inteiros.\nvAA = vBB >> 0xFF</item>
		<item>Signally desloca vBB para a direita pelo número de bits especificado por 0xFF e armazena o resultado no registro vAA. Todos os valores são inteiros.\nvAA = vBB >>> 0xFF</item>
		<item>Chama (executa) um método de assinatura polimórfica com parâmetros. Presente em arquivos Dex desde a versão 038.</item>
		<item>Chama (executa) um método de assinatura polimórfica com parâmetros, mas os parâmetros devem estar contidos em registradores numerados sequencialmente. Presente em arquivos Dex desde a versão 038.</item>
		<item>Permite (inicia) chamar um site com parâmetros. Presente em arquivos Dex desde a versão 038.</item>
		<item>Permite (inicia) chamar um site com parâmetros, mas os parâmetros devem estar contidos em registros com números em ordem. Presente em arquivos Dex desde a versão 038.</item>
		<item>Coloca uma referência a um identificador de método no registro vAA. Presente em arquivos Dex desde a versão 039.</item>
		<item>Coloca uma referência ao protótipo do método no registro vAA. Presente em arquivos Dex desde a versão 039.</item>
	</string-array>
	<string-array name="years_or_days">
		<item>years</item>
		<item>days</item>
	</string-array>
	<string-array name="store_type">
		<item>Built-in</item>
		<item>Personalizado</item>
	</string-array>
	<string-array name="aapt2_dump_descr">
		<item>Imprimir informações extraídas do manifesto do APK.</item>
		<item>Imprima todas as configurações usadas por um recurso no APK.</item>
		<item>Imprima as permissões extraídas do manifesto do APK.</item>
		<item>Imprima o conteúdo do pool de strings da tabela de recursos no APK.</item>
		<item>Imprima o conteúdo da tabela de recursos do APK.</item>
		<item>Imprima os recursos &lt;overlayable> de um APK.</item>
	</string-array>
	<string-array name="app_theme">
		<item>Light</item>
		<item>Dark</item>
		<item>Black</item>
	</string-array>
	<string-array name="jadx_sets">
		<item>Modo alternativo</item>
		<item>Desofuscação</item>
		<item>Fugir do Unicode</item>
		<item>Mostrar código inconsistente</item>
	</string-array>
	<string-array name="copy_variants">
		<item>Renomear</item>
		<item>Renomear apenas arquivos</item>
		<item>Substituir</item>
		<item>Pular</item>
	</string-array>
	<string-array name="menu_pos">
		<item>Eaquerda</item>
		<item>Direito</item>
	</string-array>
	<string-array name="checksum_names">
		<item>Todas MAIÚSCULAS</item>
		<item>Separe com dois pontos</item>
	</string-array>
	<string-array name="tooltips_names">
		<item>Smali</item>
		<item>XML</item>
	</string-array>
	<string-array name="refresh_res">
		<item>Adicionar novos recursos (somente arquivos)</item>
		<item>Excluir recursos ausentes</item>
	</string-array>
	<string-array name="sort">
		<item>Nome</item>
		<item>Nome (Reverso)</item>
		<item>Tipo</item>
		<item>Tipo (Reverso)</item>
		<item>Tamanho</item>
		<item>Tamanho (Reverso)</item>
		<item>Tempo</item>
		<item>Tempo (Reverso)</item>
	</string-array>
	<string-array name="color_var">
		<item>HEX-Color</item>
		<item>Código Smali</item>
		<item>A,R,G,B</item>
	</string-array>
	<string-array name="format">
		<item>@string/jks</item>
		<item>@string/pkcs12</item>
		<item>@string/bks</item>
		<item>@string/pk8</item>
	</string-array>
	<string-array name="resDecodeMode">
		<item>Não descompilar</item>
		<item>Descompilar ao diretório principal</item>
		<item>Descompilar em um diretório separado</item>
		<item>Tente mesclar pacotes</item>
	</string-array>
	<string-array name="converter_items">
		<item>Texto &lt;-> Base64</item>
		<item>Texto &lt;-> Unicode</item>
		<item>Texto &lt;-> Codificação de URL</item>
		<item>Texto &lt;-> MD5</item>
		<item>Texto &lt;-> SHA-1</item>
		<item>Texto &lt;-> SHA-224</item>
		<item>Texto &lt;-> SHA-256</item>
		<item>Texto &lt;-> SHA-384</item>
		<item>Texto &lt;-> SHA-512</item>
		<item>Texto &lt;-> Array (UTF-8)</item>
		<item>Texto &lt;-> Array (UTF-16)</item>
		<item>Texto &lt;-> Array (UTF-16LE)</item>
		<item>Texto &lt;-> Array (UTF-16BE)</item>
		<item>Texto &lt;-> Array (US-ASCII)</item>
		<item>Texto &lt;-> Array (ISO-8859-1)</item>
		<item>Texto &lt;-> Array (CP1251)</item>
		<item>Decimal &lt;-> Binário</item>
		<item>Decimal &lt;-> Octal</item>
		<item>Decimal &lt;-> Hex</item>
		<item>Decimal &lt;-> Hex (0x0)</item>
		<item>Decimal &lt;-> Hex (0x00000000)</item>
		<item>Float &lt;-> Binary</item>
		<item>Float &lt;-> Octal</item>
		<item>Float &lt;-> Hex</item>
		<item>Float &lt;-> Hex (0x0)</item>
		<item>Float &lt;-> Hex (0x00000000)</item>
		<item>Color &lt;-> Smali</item>
		<item>Color &lt;-> Decimal</item>
		<item>Color &lt;-> A,R,G,B</item>
        <item>Date &lt;-> Milliseconds</item>
		<item>Date &lt;-> Hex</item>
	</string-array>
	<string-array name="installLocation">
		<item>Não configurado</item>
		<item>Auto</item>
		<item>Apenas interno</item>
		<item>Externo preferido</item>
	</string-array>
	<string-array name="xml_format_variants">
		<item>Padrão</item>
		<item>Apktool</item>
		<item>Android Studio</item>
		<item>Truque Simples</item>
	</string-array>
	<string-array name="orientation_variants">
		<item>Padrão</item>
		<item>Paisagem</item>
		<item>Retrato</item>
	</string-array>
	<string-array name="auto_save_variants">
		<item>Desativo</item>
		<item>15 segundos</item>
		<item>30 segundos</item>
		<item>1 minuto</item>
		<item>5 minutos</item>
	</string-array>
	<string-array name="to_vector_values">
		<item>Imagem adaptada (qualidade baixa)</item>
		<item>Imagem de alta qualidade (tamanho maior)</item>
		<item>Converter para SVG</item>
	</string-array>
	<string-array name="backup_values">
		<item>Configurações</item>
		<item>Favoritos</item>
		<item>Pesquisar/Substituir o histórico</item>
		<item>Dicionários</item>
	</string-array>
	<string-array name="split_dex_items">
		<item>por número de methods/fields</item>
		<item>into equal parts</item>
	</string-array>
	<string-array name="ds_display_items">
		<item>Data primeiro</item>
		<item>Dimensione primeiro</item>
	</string-array>
	<string-array name="editor_themes">
		<item>Padrão</item>
		<item>Novo</item>
	</string-array>
	<string-array name="bing_translator_codes">
		<item>auto-detect</item>
		<item>az</item>
		<item>sq</item>
		<item>en</item>
		<item>ar</item>
		<item>hy</item>
		<item>af</item>
		<item>bn</item>
		<item>bg</item>
		<item>bs</item>
		<item>cy</item>
		<item>hu</item>
		<item>vi</item>
		<item>ht</item>
		<item>nl</item>
		<item>el</item>
		<item>gu</item>
		<item>da</item>
		<item>he</item>
		<item>id</item>
		<item>ga</item>
		<item>is</item>
		<item>es</item>
		<item>it</item>
		<item>kk</item>
		<item>kn</item>
		<item>yue</item>
		<item>ca</item>
		<item>otq</item>
		<item>zh-Hant</item>
		<item>zh-Hans</item>
		<item>ko</item>
		<item>lv</item>
		<item>lt</item>
		<item>mg</item>
		<item>ms</item>
		<item>ml</item>
		<item>mt</item>
		<item>mi</item>
		<item>mr</item>
		<item>de</item>
		<item>ne</item>
		<item>nb</item>
		<item>or</item>
		<item>pa</item>
		<item>fa</item>
		<item>pl</item>
		<item>pt</item>
		<item>pt-PT</item>
		<item>ro</item>
		<item>ru</item>
		<item>sm</item>
		<item>sr-Cyrl</item>
		<item>sr-Latn</item>
		<item>sk</item>
		<item>sl</item>
		<item>sw</item>
		<item>ty</item>
		<item>th</item>
		<item>ta</item>
		<item>te</item>
		<item>to</item>
		<item>tr</item>
		<item>uk</item>
		<item>ur</item>
		<item>fj</item>
		<item>fil</item>
		<item>fi</item>
		<item>fr</item>
		<item>hi</item>
		<item>mww</item>
		<item>hr</item>
		<item>cs</item>
		<item>sv</item>
		<item>et</item>
		<item>yua</item>
		<item>ja</item>
		<item>am</item>
		<item>as</item>
		<item>prs</item>
		<item>fr-CA</item>
		<item>iu</item>
		<item>km</item>
		<item>tlh-Latn</item>
		<item>ku</item>
		<item>kmr</item>
		<item>lo</item>
		<item>my</item>
		<item>ps</item>
		<item>ti</item>
	</string-array>
	<string-array name="bing_translator_names">
		<item>Automático</item>
		<item>Azerbaijão (Latim)</item>
		<item>Albanês</item>
		<item>Inglês</item>
		<item>Árabe</item>
		<item>Armênio</item>
		<item>Africâner</item>
		<item>Bengalês</item>
		<item>Búlgaro</item>
		<item>Bósnio</item>
		<item>Galês</item>
		<item>Húngaro</item>
		<item>Vietnamita</item>
		<item>Crioulo Haitiano</item>
		<item>Holandês</item>
		<item>Grego</item>
		<item>Guzerate</item>
		<item>Dinamarquês</item>
		<item>Hebraico</item>
		<item>Indonésio</item>
		<item>Irlandês</item>
		<item>Islandês</item>
		<item>Espanhol</item>
		<item>Italiano</item>
		<item>Cazaque</item>
		<item>Canarês</item>
		<item>Cantonês Tradicional</item>
		<item>Catalão</item>
		<item>Keretarian Otomi</item>
		<item>Chinês Tradicional</item>
		<item>Chinês Simplificado</item>
		<item>Coreano</item>
		<item>Letão</item>
		<item>Lituano</item>
		<item>Malgaxe</item>
		<item>Malaio</item>
		<item>Malaiala</item>
		<item>Maltês</item>
		<item>Maori</item>
		<item>Marata</item>
		<item>Alemão</item>
		<item>Nepalês</item>
		<item>Norueguês</item>
		<item>Oriá</item>
		<item>Panjabi</item>
		<item>Persa</item>
		<item>Polonês</item>
		<item>Português (Brasil)</item>
		<item>Português (Portugal)</item>
		<item>Romeno</item>
		<item>Russo</item>
		<item>Samoa</item>
		<item>Sérvio (Cirílico)</item>
		<item>Sérvio (Latim)</item>
		<item>Eslovaco</item>
		<item>Esloveno</item>
		<item>Suaíle</item>
		<item>Tahiti</item>
		<item>Tailandês</item>
		<item>Tâmil</item>
		<item>Telugo</item>
		<item>Tonga</item>
		<item>Turco</item>
		<item>Ucraniano</item>
		<item>Urdu</item>
		<item>Fiji</item>
		<item>Filipino</item>
		<item>Finlandês</item>
		<item>Francês</item>
		<item>Hindi</item>
		<item>Hmong Dhow</item>
		<item>Croata</item>
		<item>Tcheco</item>
		<item>Sueco</item>
		<item>Estoniano</item>
		<item>Yucatec Maya</item>
		<item>Japonês</item>
		<item>Amárico</item>
		<item>Assamês</item>
		<item>Dari</item>
		<item>Francês (Canadá)</item>
		<item>Inuktitut</item>
		<item>Quemer</item>
		<item>Klingon (Latim)</item>
		<item>Curdo (Central)</item>
		<item>Curdo (Norte)</item>
		<item>Laosiano</item>
		<item>Mianmar (Birmanês)</item>
		<item>Pastó</item>
		<item>Tigrinya</item>
	</string-array>
	<string-array name="google_translator_codes">
		<item>auto</item>
		<item>af</item>
		<item>sq</item>
		<item>am</item>
		<item>ar</item>
		<item>hy</item>
		<item>az</item>
		<item>eu</item>
		<item>be</item>
		<item>bn</item>
		<item>bs</item>
		<item>bg</item>
		<item>ca</item>
		<item>ceb</item>
		<item>ny</item>
		<item>zh-cn</item>
		<item>zh-tw</item>
		<item>co</item>
		<item>hr</item>
		<item>cs</item>
		<item>da</item>
		<item>nl</item>
		<item>en</item>
		<item>eo</item>
		<item>et</item>
		<item>tl</item>
		<item>fi</item>
		<item>fr</item>
		<item>fy</item>
		<item>gl</item>
		<item>ka</item>
		<item>de</item>
		<item>el</item>
		<item>gu</item>
		<item>ht</item>
		<item>ha</item>
		<item>haw</item>
		<item>iw</item>
		<item>hi</item>
		<item>hmn</item>
		<item>hu</item>
		<item>is</item>
		<item>ig</item>
		<item>id</item>
		<item>ga</item>
		<item>it</item>
		<item>ja</item>
		<item>jw</item>
		<item>kn</item>
		<item>kk</item>
		<item>km</item>
		<item>ko</item>
		<item>ku</item>
		<item>ky</item>
		<item>lo</item>
		<item>la</item>
		<item>lv</item>
		<item>lt</item>
		<item>lb</item>
		<item>mk</item>
		<item>mg</item>
		<item>ms</item>
		<item>ml</item>
		<item>mt</item>
		<item>mi</item>
		<item>mr</item>
		<item>mn</item>
		<item>my</item>
		<item>ne</item>
		<item>no</item>
		<item>ps</item>
		<item>fa</item>
		<item>pl</item>
		<item>pt</item>
		<item>ma</item>
		<item>ro</item>
		<item>ru</item>
		<item>sm</item>
		<item>gd</item>
		<item>sr</item>
		<item>st</item>
		<item>sn</item>
		<item>sd</item>
		<item>si</item>
		<item>sk</item>
		<item>sl</item>
		<item>so</item>
		<item>es</item>
		<item>su</item>
		<item>sw</item>
		<item>sv</item>
		<item>tg</item>
		<item>ta</item>
		<item>te</item>
		<item>th</item>
		<item>tr</item>
		<item>uk</item>
		<item>ur</item>
		<item>uz</item>
		<item>vi</item>
		<item>cy</item>
		<item>xh</item>
		<item>yi</item>
		<item>yo</item>
		<item>zu</item>
		<item>or</item>
		<item>pa</item>
		<item>rw</item>
		<item>tt</item>
		<item>tk</item>
		<item>ug</item>
	</string-array>
	<string-array name="google_translator_names">
		<item>Automático</item>
		<item>Africâner</item>
		<item>Albanês</item>
		<item>Amárico</item>
		<item>Árabe</item>
		<item>Armênio</item>
		<item>Azerbaijano</item>
		<item>Basco</item>
		<item>Bielorrusso</item>
		<item>Bengalês</item>
		<item>Bósnio</item>
		<item>Búlgaro</item>
		<item>Catalão</item>
		<item>Cebuano</item>
		<item>Cinianja</item>
		<item>Chinês Simplificado</item>
		<item>Chinês Tradicional</item>
		<item>Corso</item>
		<item>Croata</item>
		<item>Tcheco</item>
		<item>Dinamarquês</item>
		<item>Holandês</item>
		<item>Inglês</item>
		<item>Esperanto</item>
		<item>Estoniano</item>
		<item>Filipino</item>
		<item>Finlandês</item>
		<item>Francês</item>
		<item>Frisiã</item>
		<item>Galego</item>
		<item>Georgiano</item>
		<item>Alemão</item>
		<item>Grego</item>
		<item>Guzerate</item>
		<item>Crioulo Haitiano</item>
		<item>Hausa</item>
		<item>Havaiano</item>
		<item>Hebraico</item>
		<item>Hindi</item>
		<item>Hmong</item>
		<item>Húngaro</item>
		<item>Islandês</item>
		<item>Igbo</item>
		<item>Indonésio</item>
		<item>Irlandês</item>
		<item>Italiano</item>
		<item>Japonês</item>
		<item>Javanês</item>
		<item>Canarês</item>
		<item>Cazaque</item>
		<item>Quemer</item>
		<item>Coreano</item>
		<item>Curdo (Curmanji)</item>
		<item>Quirguiz</item>
		<item>Laosiano</item>
		<item>Latim</item>
		<item>Letão</item>
		<item>Lituano</item>
		<item>Luxemburguês</item>
		<item>Macedônio</item>
		<item>Malgaxe</item>
		<item>Malaio</item>
		<item>Malaiala</item>
		<item>Maltês</item>
		<item>Maori</item>
		<item>Marata</item>
		<item>Mongol</item>
		<item>Mianmar (Birmanês)</item>
		<item>Nepalês</item>
		<item>Norueguês</item>
		<item>Pastó</item>
		<item>Persa</item>
		<item>Polonês</item>
		<item>Português</item>
		<item>Panjabi</item>
		<item>Romeno</item>
		<item>Russo</item>
		<item>Samoana</item>
		<item>Ânglica Escocesa</item>
		<item>Sérvio</item>
		<item>Sepedi</item>
		<item>Xona</item>
		<item>Sindi</item>
		<item>Cingalês</item>
		<item>Eslovaco</item>
		<item>Esloveno</item>
		<item>Somali</item>
		<item>Espanhol</item>
		<item>Sundanês</item>
		<item>Suaíle</item>
		<item>Sueco</item>
		<item>Tadjique</item>
		<item>Tâmil</item>
		<item>Telugo</item>
		<item>Tailandês</item>
		<item>Turco</item>
		<item>Ucraniano</item>
		<item>Urdu</item>
		<item>Usbeque</item>
		<item>Vietnamita</item>
		<item>Galês</item>
		<item>Xhosa</item>
		<item>Iídiche</item>
		<item>Iorubá</item>
		<item>Zulu</item>
		<item>Oriá</item>
		<item>Panjabi</item>
		<item>Ruanda</item>
		<item>Tártaro</item>
		<item>Turcomeno</item>
		<item>Uigur</item>
	</string-array>
	<string-array name="yandex_translator_codes">
		<item>auto</item>
		<item>af</item>
		<item>sq</item>
		<item>am</item>
		<item>ar</item>
		<item>hy</item>
		<item>az</item>
		<item>ba</item>
		<item>eu</item>
		<item>be</item>
		<item>bn</item>
		<item>bs</item>
		<item>bg</item>
		<item>my</item>
		<item>ca</item>
		<item>ceb</item>
		<item>zh</item>
		<item>cv</item>
		<item>hr</item>
		<item>cs</item>
		<item>da</item>
		<item>nl</item>
		<item>sjn</item>
		<item>emj</item>
		<item>en</item>
		<item>eo</item>
		<item>et</item>
		<item>fi</item>
		<item>fr</item>
		<item>gl</item>
		<item>ka</item>
		<item>de</item>
		<item>el</item>
		<item>gu</item>
		<item>ht</item>
		<item>he</item>
		<item>mrj</item>
		<item>hi</item>
		<item>hu</item>
		<item>is</item>
		<item>id</item>
		<item>ga</item>
		<item>it</item>
		<item>ja</item>
		<item>jv</item>
		<item>kn</item>
		<item>kk</item>
		<item>kazlat</item>
		<item>km</item>
		<item>ko</item>
		<item>ky</item>
		<item>lo</item>
		<item>la</item>
		<item>lv</item>
		<item>lt</item>
		<item>lb</item>
		<item>mk</item>
		<item>mg</item>
		<item>ms</item>
		<item>ml</item>
		<item>mt</item>
		<item>mi</item>
		<item>mr</item>
		<item>mhr</item>
		<item>mn</item>
		<item>ne</item>
		<item>no</item>
		<item>pap</item>
		<item>fa</item>
		<item>pl</item>
		<item>pt</item>
		<item>pa</item>
		<item>ro</item>
		<item>ru</item>
		<item>gd</item>
		<item>sr</item>
		<item>si</item>
		<item>sk</item>
		<item>sl</item>
		<item>es</item>
		<item>su</item>
		<item>sw</item>
		<item>sv</item>
		<item>tl</item>
		<item>tg</item>
		<item>ta</item>
		<item>tt</item>
		<item>te</item>
		<item>th</item>
		<item>tr</item>
		<item>udm</item>
		<item>uk</item>
		<item>ur</item>
		<item>uz</item>
		<item>uzbcyr</item>
		<item>vi</item>
		<item>cy</item>
		<item>xh</item>
		<item>sah</item>
		<item>yi</item>
	</string-array>
	<string-array name="yandex_translator_names">
		<item>Automático</item>
		<item>Africâner</item>
		<item>Albanês</item>
		<item>Amárico</item>
		<item>Árabe</item>
		<item>Armênio</item>
		<item>Azerbaijano</item>
		<item>Basquires</item>
		<item>Basco</item>
		<item>Bielorrusso</item>
		<item>Bengalês</item>
		<item>Bósnio</item>
		<item>Búlgaro</item>
		<item>Birmanês</item>
		<item>Catalão</item>
		<item>Cebuano</item>
		<item>Chinês</item>
		<item>Chuvacho</item>
		<item>Croata</item>
		<item>Tcheco</item>
		<item>Dinamarquês</item>
		<item>Holandês</item>
		<item>Élfico (Sindarin)</item>
		<item>Emoji</item>
		<item>Inglês</item>
		<item>Esperanto</item>
		<item>Estoniano</item>
		<item>Finlandês</item>
		<item>Francês</item>
		<item>Galego</item>
		<item>Georgiano</item>
		<item>Alemão</item>
		<item>Grego</item>
		<item>Guzerate</item>
		<item>Haitiano</item>
		<item>Hebraico</item>
		<item>Hill Mari</item>
		<item>Hindi</item>
		<item>Húngaro</item>
		<item>Islandês</item>
		<item>Indonésio</item>
		<item>Irlandês</item>
		<item>Italiano</item>
		<item>Japonês</item>
		<item>Javanês</item>
		<item>Canarês</item>
		<item>Cazaque</item>
		<item>Cazaque (Latim)</item>
		<item>Quemer</item>
		<item>Coreano</item>
		<item>Quirguiz</item>
		<item>Laosiano</item>
		<item>Latim</item>
		<item>Letão</item>
		<item>Lituano</item>
		<item>Luxemburguês</item>
		<item>Macedônio</item>
		<item>Malgaxe</item>
		<item>Malaio</item>
		<item>Malaiala</item>
		<item>Maltês</item>
		<item>Maori</item>
		<item>Marata</item>
		<item>Mari</item>
		<item>Mongol</item>
		<item>Nepalês</item>
		<item>Norueguês</item>
		<item>Papiamento</item>
		<item>Persa</item>
		<item>Polonês</item>
		<item>Português</item>
		<item>Panjabi</item>
		<item>Romeno</item>
		<item>Russo</item>
		<item>Galês</item>
		<item>Sérvio</item>
		<item>Cingalês</item>
		<item>Eslovaco</item>
		<item>Esloveno</item>
		<item>Espanhol</item>
		<item>Sundanês</item>
		<item>Suaíle</item>
		<item>Sueco</item>
		<item>Tagalo</item>
		<item>Tadjique</item>
		<item>Tâmil</item>
		<item>Tártaro</item>
		<item>Telugo</item>
		<item>Tailandês</item>
		<item>Turco</item>
		<item>Udmurtes</item>
		<item>Ucraniano</item>
		<item>Urdu</item>
		<item>Usbeque</item>
		<item>Usbeque (Cirílico)</item>
		<item>Vietnamita</item>
		<item>Galês</item>
		<item>Xhosa</item>
		<item>Rubi</item>
		<item>Iídiche</item>
	</string-array>
</resources>