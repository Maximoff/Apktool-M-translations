<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string-array name="smali_help_names">
		<item>Registros</item>
		<item>Valores literales</item>
		<item>Tipos de datos primitivos</item>
	</string-array>
	<string-array name="smali_help_values" formatted="false">
		<item>vA es un registro de 4 bits con el rango de valores v0 - v15\nvAA es un registro de 8 bits con un rango de valores de v0 - v255\nvAAAA es un registro de 16 bits con un rango de valores de v0 - v65535</item>
		<item>Se utilizan 0xF, 0xFF, etc. para representar valores literales. Al igual que los registros, el número F se utiliza para representar un rango de valores, por ejemplo:\nEl rango de valores 0xF está representado por [-0x8, 0x7]\nEl rango de valores de 0xFF está representado por [-0x80, 0x7F]</item>
		<item>V - vacío, Z - booleano, B - byte\nC - char, S - corto, I - int\nJ - largo, F - flotante, D - doble\nnulo: solo se puede utilizar para tipos de devolución\nbooleano: almacena el valor verdadero o falso\nbyte: almacena un número entero de -128 a 127 y ocupa 1 byte\nbreve: almacena un número entero de -32768 a 32767 y ocupa 2 bytes\nint: almacena un número entero de -2147483648 a 2147483647 y ocupa 4 bytes\nde largo: almacena un número entero de -9223372036854775808 a 9223372036854775807 y ocupa 8 bytes\ndoble: almacena un número de coma flotante de ±4,9*10³²⁴ a ±1,7976931348623157*10³⁰⁸ y ocupa 8 bytes. Se utiliza un punto como separador decimal en literales fraccionarios.\nflotante: almacena un número de punto flotante de -3,4*10³⁸ a 3,4*10³⁸ y ocupa 4 bytes\nchar: almacena un solo carácter en codificación UTF-16 y ocupa 2 bytes, por lo que el rango de valores almacenados es de 0 a 65535.</item>
		<item>Ninguna acción.</item>
		<item>Mueve el valor del registro vB al registro vA.</item>
		<item>Mueve el valor del registro vBBBB al registro vAA.</item>
		<item>Mueve el valor del registro vBBBB al registro vAAAA.</item>
		<item>Mueve el valor largo/doble del par de registros (vB, vB+1) al par de registros vA, vA+1.</item>
		<item>Mueve el valor largo/doble de un par de registros (vBBBB, vBBBB+1) a un par de registros vAA, vAA+1.</item>
		<item>Mueve el valor largo/doble de un par de registros (vBBBB, vBBBB+1) a un par de registros vAAAA, vAAAA+1.</item>
		<item>Mueve una referencia de objeto del registro vB al registro vA.</item>
		<item>Mueve una referencia de objeto del registro vBBBB al registro vAA.</item>
		<item>Mueve una referencia de objeto del registro vBBBB al registro vAAAA.</item>
		<item>Mueve el valor de retorno del método llamado anteriormente al registro vAA.</item>
		<item>Mueve el valor largo/doble devuelto por el método llamado anteriormente al par de registros vAA, vAA+1.</item>
		<item>Mueve la referencia del objeto devuelta por el método llamado anteriormente al registro vAA.</item>
		<item>Mueve la referencia al objeto excluido emitido durante la llamada al método (durante la ejecución) al registro vAA.</item>
		<item>Devolución sin valor de retorno.</item>
		<item>Regrese devolviendo el valor del registro vAA.</item>
		<item>Regrese devolviendo un valor doble/largo en un par de registros vAA, vAA+1.</item>
		<item>Regrese devolviendo el valor de la referencia del objeto del registro vAA.</item>
		<item>Coloca una constante de 4 bits en el registro vA.</item>
		<item>Coloca una constante de 16 bits en el registro vAA.</item>
		<item>Coloca una constante entera en el registro vAA.</item>
		<item>Coloca una constante de 16 bits en los bits superiores del registro vAA. Se utiliza para inicializar valores flotantes (punto flotante).</item>
		<item>Coloca una constante entera de 16 bits en el par de registros vAA, vAA+1, convirtiendo la constante entera en una constante larga.</item>
		<item>Coloca una constante entera de 32 bits en el par de registros vAA, vAA+1, convirtiendo la constante entera en una constante larga.</item>
		<item>Coloca una constante de 64 bits en el par de registros vAA, vAA+1.</item>
		<item>Coloca una constante de 16 bits en los 16 bits superiores del par de registros vAA, vAA+1. Se utiliza para inicializar valores dobles (punto flotante).</item>
		<item>Coloca una referencia a la cadena especificada en el registro vAA.</item>
		<item>Coloca una referencia a la cadena especificada en el registro vAA.</item>
		<item>Coloca una referencia a la constante de cadena (cadena) identificada por string_id en el registro vAA.</item>
		<item>Obtiene el monitor de objetos al que hace referencia el registro vAA.</item>
		<item>Libera el monitor de objetos al que hace referencia el registro vAA.</item>
		<item>Comprueba si una referencia de objeto contenida en el registro vAA se puede convertir a la clase identificada por type_id. Lanza una ClassCastException si no puede; de lo contrario, continúa la ejecución.</item>
		<item>Comprueba si el contenido del registro vB es una instancia de la clase identificada por type_id. Establece el registro vA en un valor distinto de cero si está presente y en 0 si no.\nvA = vB tipo de instancia? 10</item>
		<item>Determina el número de elementos de la matriz del registro vB y coloca el valor en el registro vA.\nvA = vB.longitud</item>
		<item>Crea una instancia de un tipo de objeto y coloca una referencia a la instancia creada en el registro vAA.</item>
		<item>Crea una nueva matriz de variables type_id con el tamaño de los elementos del registro vB y coloca una referencia a la matriz en el registro vA.</item>
		<item>Crea una nueva matriz de datos de tipo type_id y la llena con parámetros (es decir, no hay matrices largas/dobles, pero se permiten tipos de referencia). Se puede obtener una referencia a la matriz recién creada usando la declaración move-result-object inmediatamente después de esta declaración (si se va a usar alguna).</item>
		<item>Crea una nueva matriz de datos de tipo type_id y la llena con una variedad de parámetros (es decir, no hay matrices largas/dobles, pero los tipos de referencia son aceptables). Se puede obtener una referencia a la matriz recién creada usando la declaración move-result-object inmediatamente después de esta declaración (si se va a usar alguna).</item>
		<item>Llena la matriz a la que se hace referencia en el registro vAA con datos estáticos. La ubicación de los datos es la suma de la posición de la instrucción actual y el desplazamiento.</item>
		<item>Lanza un objeto de excepción. Una referencia al objeto de excepción en el registro vAA.</item>
		<item>Salte incondicionalmente a un desplazamiento corto (entero) de 8 bits.</item>
		<item>Salto incondicional al desplazamiento de 16 bits.</item>
		<item>Salto incondicional al desplazamiento de 32 bits.</item>
		<item>Implementa el operador Switch cuando las constantes de control están cerca unas de otras (en una fila). La instrucción utiliza una tabla de índice. El desplazamiento de instrucción para un caso particular está determinado por el índice vAA. Si el índice vAA va más allá de la tabla, la ejecución continúa con la siguiente declaración (predeterminado).</item>
		<item>Implementa el operador Switch en caso de una tabla dispersa. La instrucción utiliza una tabla que especifica compensaciones para cada constante. Si no se encuentran coincidencias en la tabla, se ejecuta la siguiente instrucción (caso predeterminado).</item>
		<item>Compara los valores flotantes (punto flotante) en vBB y vCC y coloca el valor entero en el registro vAA:\nvAA = vBB &lt;vCC? sí: 1, no: -1, igual: 0</item>
		<item>Compara los valores flotantes (punto flotante) en vBB y vCC y coloca el valor entero en el registro vAA:\nvAA = vBB &lt;vCC? sí: 1, no: -1, igual: 0</item>
		<item>Compara los valores dobles (punto flotante) en vBB y vCC y coloca el valor entero en el registro vAA:\nvAA = (vBB, vBB+1) &lt; (vCC, vCC+1) ? y\nsí: 1, no: -1, igual: 0</item>
		<item>Compara los valores dobles (punto flotante) en vBB y vCC y coloca el valor entero en el registro vAA:\nvAA = (vBB, vBB+1) > (vCC, vCC+1) ? sí: 1, no: -1, igual: 0</item>
		<item>Compara los valores largos (enteros) en vBB y vCC y coloca el valor entero (entero) en el registro vAA:\nvAA = (vBB, vBB+1) > (vCC, vCC+1) ? sí: 1, no: -1, igual: 0</item>
		<item>Salta a la etiqueta especificada si vA == vB. vA y vB contienen valores enteros.\n(eq es la abreviatura de iguales)</item>
		<item>Salta a la etiqueta especificada si vA != vB. vA y vB contienen valores enteros.\n(ne es la abreviatura de No iguales)</item>
		<item>Salta a la etiqueta especificada si vA &lt;vB. vA y vB contienen valores enteros.\n(Es la abreviatura de Menos que)</item>
		<item>Salta a la etiqueta especificada si vA &lt;= vB. vA y vB contienen valores enteros.\n(le es una abreviatura de Menos que o Igual/Menos o igual)</item>
		<item>Salta a la etiqueta especificada si vA > vB. vA y vB contienen valores enteros.\n(gt es la abreviatura de Mayor que/Más que)</item>
		<item>Salta a la etiqueta especificada si vA >= vB. vA y vB contienen valores enteros.\n(ge es la abreviatura de Mayor que o Igual)</item>
		<item>Salta a la etiqueta especificada si vAA == 0. vAA contiene un valor entero.\n(eqz es la abreviatura de Igual a cero)</item>
		<item>Salta a la etiqueta especificada si vAA! = 0. vAA contiene un valor entero.\n(nez es la abreviatura de No es igual a cero)</item>
		<item>Salta a la etiqueta especificada si vAA &lt; 0. vAA contiene un valor entero.\n(ltz es la abreviatura de Menos que cero)</item>
		<item>Salta a la etiqueta especificada si vAA &lt;= 0. vAA contiene un valor entero.\n(lez es una abreviatura de Menor o igual a cero/Menos o igual a cero)</item>
		<item>Salta a la etiqueta especificada si vAA > 0. vAA contiene un valor entero.\n(gtz es la abreviatura de Mayor que cero)</item>
		<item>Salta a la etiqueta especificada si vAA >= 0. vAA contiene un valor entero.\n(gez es una abreviatura de Mayor o igual a cero)</item>
		<item>Obtiene un valor entero en el índice contenido en vCC de la matriz a la que se hace referencia en vBB y lo coloca en el registro vAA.\nvAA = vBB[vCC]</item>
		<item>Obtiene, en el índice contenido en vCC, de la matriz referenciada en vBB, un valor doble/largo y lo coloca en el par de registros vAA, vAA+1.\n(vAA, vAA+1) = vBB[vCC]</item>
		<item>Recibe, en el índice contenido en vCC, del array referenciado en vBB, una referencia al objeto y lo coloca en el registro vAA.\nvAA = vBB[vCC]</item>
		<item>Obtiene, en el índice contenido en vCC, de la matriz referenciada en vBB, un valor booleano y lo coloca en el registro vAA.\nvAA = vBB[vCC]</item>
		<item>Recupera, en el índice contenido en vCC, de la matriz referenciada en vBB, un valor de byte (entero) y lo coloca en el registro vAA.\nvAA = vBB[vCC]</item>
		<item>Recupera, en el índice contenido en vCC, de la matriz referenciada en vBB, un valor de carácter y lo coloca en el registro vAA.\nvAA = vBB[vCC]</item>
		<item>Recupera, en el índice contenido en vCC, de la matriz referenciada en vBB, un valor corto (entero) y lo coloca en el registro vAA.\nvAA = vBB[vCC]</item>
		<item>Coloca el valor entero de vAA en la matriz a la que se hace referencia en vBB con el elemento que contiene el registro vCC.\nvBB[vCC] = vAA</item>
		<item>Coloca un valor doble/largo del par de registros vAA, vAA+1 en la matriz a la que se hace referencia en vBB, con el elemento que contiene el registro vCC.\nvBB[vCC] = (vAA, vAA+1)</item>
		<item>Coloca una referencia a un objeto de vAA en la matriz a la que se hace referencia en vBB con un elemento con el registro vCC.\nvBB[vCC] = vAA</item>
		<item>Coloca el valor booleano de vAA en la matriz a la que hace referencia vBB con el elemento que contiene el registro vCC.\nvBB[vCC] = vAA</item>
		<item>Coloca el valor del byte (entero) de vAA en la matriz a la que se hace referencia en vBB con el elemento que contiene el registro vCC.\nvBB[vCC] = vAA</item>
		<item>Coloca el valor char (carácter) de vAA en la matriz a la que se hace referencia en vBB por elemento con registro vCC.\nvBB[vCC] = vAA</item>
		<item>Coloca el valor corto (entero) de vAA en la matriz a la que se hace referencia en vBB con el elemento que contiene el registro vCC.\nvBB[vCC] = vAA</item>
		<item>Lee el valor del campo de instancia y lo coloca en el registro vA. La referencia a la clase que contiene este campo está en el registro vB.\nvA = vB.campo</item>
		<item>Lee un valor doble/largo de un campo de instancia y lo coloca en un par de registros (vA, vA+1). La referencia a la clase que contiene este campo está en el registro vB.\n(vA, vA+1) = vB.campo</item>
		<item>Lee una referencia de objeto de un campo de instancia y la coloca en el registro vA. La referencia a la clase que contiene este campo está en el registro vB.\nvA = vB.campo</item>
		<item>Lee un valor booleano del campo de instancia y lo coloca en el registro vA. La referencia a la clase que contiene este campo está en el registro vB.\nvA = vB.campo</item>
		<item>Lee un valor de byte (entero) de un campo de instancia y lo coloca en el registro vA. La referencia a la clase que contiene este campo está en el registro vB.\nvA = vB.campo</item>
		<item>Lee un valor de carácter de un campo de instancia y lo coloca en el registro vA. La referencia a la clase que contiene este campo está en el registro vB.\nvA = vB.campo</item>
		<item>Lee un valor corto (entero) de un campo de instancia y lo coloca en el registro vA. La referencia a la clase que contiene este campo está en el registro vB.\nvA = vB.campo</item>
		<item>Coloca el valor del registro vA en el campo de instancia. La referencia a la clase que contiene este campo está en el registro vB.\nvB.campo = vA</item>
		<item>Coloca un valor doble/largo de un par de registros (vA, vA+1) en un campo de instancia. La referencia a la clase que contiene este campo está en el registro vB.\nvB.campo = (vA, vA+1)</item>
		<item>Coloca una referencia a un objeto del registro vA en el campo de instancia. La referencia a la clase que contiene este campo está en el registro vB.\nvB.campo = vA</item>
		<item>Coloca el valor booleano del registro vA en el campo de instancia. La referencia a la clase que contiene este campo está en el registro vB.\nvB.campo = vA</item>
		<item>Establece el valor de byte (entero) del campo booleano especificado en la instancia a la que hace referencia el registro vB igual al valor del registro vA, es decir:\nvB.campo = vA</item>
		<item>Establece el valor char (carácter) del campo booleano especificado en la instancia a la que hace referencia el registro vB igual al valor del registro vA, es decir:\nvB.campo = vA</item>
		<item>Establece el valor corto (entero) del campo booleano especificado en la instancia a la que hace referencia el registro vB igual al valor del registro vA, es decir:\nvB.campo = vA</item>
		<item>Lee un valor de un campo estático y lo coloca en el registro vAA. No se utiliza el registro que contiene la referencia a la clase que contiene este campo.</item>
		<item>Lee un valor doble/largo de un campo estático y lo coloca en un par de registros vAA, vAA+1. No se utiliza el registro que contiene la referencia a la clase que contiene este campo.</item>
		<item>Lee una referencia de objeto de un campo estático y la coloca en el registro vAA. No se utiliza el registro que contiene la referencia a la clase que contiene este campo.</item>
		<item>Lee un valor booleano de un campo estático y lo coloca en el registro vAA. No se utiliza el registro que contiene la referencia a la clase que contiene este campo.</item>
		<item>Lee un valor de byte (entero) de un campo estático y lo coloca en el registro vAA. No se utiliza el registro que contiene la referencia a la clase que contiene este campo.</item>
		<item>Lee un valor de carácter de un campo estático y lo coloca en el registro vAA. No se utiliza el registro que contiene la referencia a la clase que contiene este campo.</item>
		<item>Lee un valor corto (entero) de un campo estático y lo coloca en el registro vAA. No se utiliza el registro que contiene la referencia a la clase que contiene este campo.</item>
		<item>Coloca el valor del registro vAA en un campo (campo estático). No se utiliza el registro que contiene la referencia a la clase que contiene este campo.</item>
		<item>Coloca un valor doble/largo de un par de registros vAA, vAA+1 en un campo (campo estático). No se utiliza el registro que contiene la referencia a la clase que contiene este campo.</item>
		<item>Coloca una referencia a un objeto del registro vAA en un campo (campo estático). No se utiliza el registro que contiene la referencia a la clase que contiene este campo.</item>
		<item>Coloca el valor booleano del registro vAA en un campo (campo estático). No se utiliza el registro que contiene la referencia a la clase que contiene este campo.</item>
		<item>Coloca un valor de byte (entero) del registro vAA en un campo (campo estático). No se utiliza el registro que contiene la referencia a la clase que contiene este campo.</item>
		<item>Coloca el valor de carácter del registro vAA en un campo estático. No se utiliza el registro que contiene la referencia a la clase que contiene este campo.</item>
		<item>Coloca el valor corto (entero) del registro vAA en un campo estático. No se utiliza el registro que contiene la referencia a la clase que contiene este campo.</item>
		<item>Llama (ejecuta) un método virtual con parámetros. Los parámetros se indican entre llaves. El primer parámetro (registro v2) contiene una referencia a la clase que contiene el método llamado, el segundo parámetro (el contenido del registro v3) se pasa al método llamado.</item>
		<item>Llama (ejecuta) un método virtual con parámetros directamente desde la clase principal.</item>
		<item>Llama (ejecuta) un método con parámetros sin los permisos del método virtual.</item>
		<item>Llama (ejecuta) un método estático con parámetros. Los parámetros se indican entre llaves. El parámetro (el contenido del registro v3) se pasa al método llamado. La clase que contiene el método llamado se indica después de las llaves.</item>
		<item>Llama (ejecuta) un método de interfaz con parámetros.</item>
		<item>Llama (ejecuta) un método virtual con parámetros, pero los parámetros deben estar contenidos en registros con números en orden.</item>
		<item>Llama (ejecuta) un método virtual con parámetros directamente desde la clase principal, pero los parámetros deben estar contenidos en registros con números secuenciales.</item>
		<item>Llama (ejecuta) un método con parámetros sin permisos de método virtual, pero los parámetros deben estar contenidos en registros numerados secuencialmente.</item>
		<item>Llama (ejecuta) un método estático con parámetros, pero los parámetros deben estar contenidos en registros con números secuenciales.</item>
		<item>Llama (ejecuta) un método de interfaz con parámetros, pero los parámetros deben estar contenidos en registros numerados secuencialmente.</item>
		<item>Calcula vA = -vB para valores de tipo entero.</item>
		<item>Calcula vA = ~vB para valores enteros.\nvA = ~vB</item>
		<item>Calcula (vA, vA+1) = -(vB, vB+1) para valores de tipo largo (entero).</item>
		<item>Calcula (vA, vA+1) = ~(vB, vB+1) para valores de tipo largo (entero).</item>
		<item>Calcula vA = -vB para valores flotantes.</item>
		<item>Calcula (vA, vA+1) = -(vB, vB+1) para valores dobles (coma flotante).</item>
		<item>Convierte un número entero de vB a largo y lo almacena en el par de registros vA, vA+1.\n(vA, vA+1) = (largo) vB</item>
		<item>Convierte un número entero de vB a flotante y lo almacena en el registro vA.\nvA = (flotante) vB</item>
		<item>Convierte un número entero de vB a doble (punto flotante) y lo almacena en un par de registros vA, vA+1.\n(vA, vA+1) = (doble) vB</item>
		<item>Convierte un valor largo (entero) de vB, vB+1 a un valor entero (entero) y lo almacena en el registro vA.\nvA = (int) (vB, vB+1)</item>
		<item>Convierte un valor largo (entero) de vB, vB+1 a un valor flotante (punto flotante) y lo almacena en el registro vA.\nvA = (flotante) (vB, vB+1)</item>
		<item>Convierte un valor largo (entero) de vB, vB+1 a un valor doble (punto flotante) y lo almacena en un par de registros vA, vA+1.\n(vA, vA+1) = (doble) (vB, vB+1)</item>
		<item>Convierte un valor flotante (punto flotante) de vB a un valor entero (entero) y lo almacena en el registro vA.\nvA = (int)vB</item>
		<item>Convierte un valor flotante (punto flotante) de vB a un valor largo (entero) y lo almacena en el par de registros vA, vA+1.\n(vA, vA+1) = (largo) vB</item>
		<item>Convierte un valor flotante (punto flotante) de vB a un valor doble (punto flotante) y lo almacena en el par de registros vA, vA+1.\n(vA, vA+1) = (doble) vB</item>
		<item>Convierte un valor doble (punto flotante) de vB, vB+1 a un valor entero (entero) y lo almacena en el registro vA.\nvA = (int) (vB, vB+1)</item>
		<item>Convierte un valor doble (punto flotante) de vB, vB+1 a un valor largo (entero) y lo almacena en un par de registros vA, vA+1.\n(vA, vA+1) = (largo) (vB, vB+1)</item>
		<item>Convierte un valor doble (punto flotante) de vB, vB+1 a un valor flotante (punto flotante) y lo almacena en el registro vA.\nvA = (flotante) (vB, vB+1)</item>
		<item>Convierte un valor entero de vB a un valor de byte y lo almacena en el registro vA.\nvA = (byte)vB</item>
		<item>Convierte un valor entero de vB a un valor char y lo almacena en el registro vA.\nvA = (carácter)vB</item>
		<item>Convierte un valor entero de vB a un valor corto y lo almacena en el registro vA.\nvA = (corto) vB</item>
		<item>Calcula vBB + vCC y almacena el resultado en el registro vAA. Todos los valores son enteros.\nvAA = vBB + vCC</item>
		<item>Calcula vBB - vCC y almacena el resultado en el registro vAA. Todos los valores son enteros.\nvAA = vBB - vCC</item>
		<item>Calcula vBB * vCC y almacena el resultado en el registro vAA. Todos los valores son enteros.\nvAA = vBB * vCC</item>
		<item>Calcula vBB/vCC y almacena el resultado en el registro vAA. Todos los valores son enteros.\nvAA = vBB / vCC</item>
		<item>Calcula vBB % vCC y almacena el resultado en el registro vAA. Todos los valores son enteros.\nvAA = vBB % vCC</item>
		<item>Calcula vBB y vCC (Y lógico) y almacena el resultado en el registro vAA. Todos los valores son enteros.\nvAA = vBB y vCC</item>
		<item>Calcula vBB | vCC (OR lógico) y almacena el resultado en el registro vAA. Todos los valores son enteros.\nvAA = vBB | CCV</item>
		<item>Calcula vBB ^ vCC (OR exclusivo) y almacena el resultado en el registro vAA. Todos los valores son enteros.\nvAA = vBB ^vCC</item>
		<item>Desplaza vBB hacia la izquierda el número de bits especificado por vCC y almacena el resultado en el registro vAA. Todos los valores son enteros.\nvAA = vBB &lt;&lt; vCC</item>
		<item>Desplaza vBB hacia la derecha según el número de bits especificado por vCC y almacena el resultado en el registro vAA. Todos los valores son enteros.\nvAA = vBB >> vCC</item>
		<item>Desplaza vBB sin conservar el signo hacia la derecha el número de bits especificado por vCC y almacena el resultado en el registro vAA. Todos los valores son enteros.\nvAA = vBB >>> vCC</item>
		<item>Calcula (vBB, vBB+1) + (vCC, vCC+1) y almacena el resultado en el par de registros vAA, vAA+1. Todos los valores son largos (enteros).\n(vAA, vAA+1) = (vBB, vBB+1) + (vCC, vCC+1)</item>
		<item>Calcula (vBB, vBB+1) - (vCC, vCC+1) y almacena el resultado en el par de registros vAA, vAA+1. Todos los valores son largos (enteros).\n(vAA, vAA+1) = (vBB, vBB+1) - (vCC, vCC+1)</item>
		<item>Calcula (vBB, vBB+1) * (vCC, vCC+1) y almacena el resultado en el par de registros vAA, vAA+1. Todos los valores son largos (enteros).\n(vAA, vAA+1) = (vBB, vBB+1) * (vCC, vCC+1)</item>
		<item>Calcula (vBB, vBB+1) / (vCC, vCC+1) y almacena el resultado en el par de registros vAA, vAA+1. Todos los valores son largos (enteros).\n(vAA, vAA+1) = (vBB, vBB+1) / (vCC, vCC+1)</item>
		<item>Calcula (vBB, vBB+1) % (vCC, vCC+1) y almacena el resultado en el par de registros vAA, vAA+1. Todos los valores son largos (enteros).\n(vAA, vAA+1) = (vBB, vBB+1) % (vCC, vCC+1)</item>
		<item>Calcula (vBB, vBB+1) y (vCC, vCC+1) (Y lógico) y almacena el resultado en el par de registros vAA, vAA+1. Todos los valores son largos (enteros).\n(vAA, vAA+1) = (vBB, vBB+1) y (vCC, vCC+1)</item>
		<item>Calcula (vBB, vBB+1) | (vCC, vCC+1) (OR lógico) y almacena el resultado en un par de registros vAA, vAA+1. Todos los valores son largos (enteros).\n(vAA, vAA+1) = (vBB, vBB+1) | (vCC, vCC+1)</item>
		<item>Calcula (vBB, vBB+1) ^ (vCC, vCC+1) (AND exclusivo) y almacena el resultado en el par de registros vAA, vAA+1. Todos los valores son largos (enteros).\n(vAA, vAA+1) = (vBB, vBB+1) ^ (vCC, vCC+1)</item>
		<item>Desplaza vBB, vBB+1 hacia la izquierda el número de bits especificado por vCC y almacena el resultado en el par de registros vAA, vAA+1. Todos los valores son largos (enteros).\n(vAA, vAA+1) = (vBB, vBB+1) &lt;&lt; vCC</item>
		<item>Desplaza vBB, vBB+1 hacia la derecha según el número de bits especificado por vCC y almacena el resultado en el par de registros vAA, vAA+1. Todos los valores son largos (enteros).\n(vAA, vAA+1) = (vBB, vBB+1) >> vCC</item>
		<item>Desplaza vBB, vBB+1 hacia la derecha sin conservar el signo por el número de bits especificado por vCC y almacena el resultado en un par de registros vAA, vA+1. Todos los valores son largos (enteros).\n(vAA, vAA+1) = (vBB, vBB+1) >>> vCC</item>
		<item>Calcula vBB + vCC y almacena el resultado en el registro vAA. Todos los valores son flotantes.\nvAA = vBB + vCC</item>
		<item>Calcula vBB - vCC y almacena el resultado en el registro vAA. Todos los valores son flotantes.\nvAA = vBB - vCC</item>
		<item>Calcula vBB * vCC y almacena el resultado en el registro vAA. Todos los valores son flotantes.\nvAA = vBB * vCC</item>
		<item>Calcula vBB/vCC y almacena el resultado en el registro vAA. Todos los valores son flotantes.\nvAA = vBB / vCC</item>
		<item>Calcula vBB % vCC y almacena el resultado en el registro vAA. Todos los valores son flotantes.\nvAA = vBB % vCC</item>
		<item>Calcula (vBB, vBB+1) + (vCC, vCC+1) y almacena el resultado en el par de registros vAA, vAA+1. Todos los valores son dobles (punto flotante).\n(vAA, vAA+1) = (vBB, vBB+1) + (vCC, vCC+1)</item>
		<item>Calcula (vBB, vBB+1) - (vCC, vCC+1) y almacena el resultado en el par de registros vAA, vAA+1. Todos los valores son dobles (punto flotante).\n(vAA, vAA+1) = (vBB, vBB+1) - (vCC, vCC+1)</item>
		<item>Calcula (vBB, vBB+1) * (vCC, vCC+1) y almacena el resultado en el par de registros vAA, vAA+1. Todos los valores son dobles (punto flotante).\n(vAA, vAA+1) = (vBB, vBB+1) * (vCC, vCC+1)</item>
		<item>Calcula (vBB, vBB+1) / (vCC, vCC+1) y almacena el resultado en el par de registros vAA, vAA+1. Todos los valores son dobles (punto flotante).\n(vAA, vAA+1) = (vBB, vBB+1) / (vCC, vCC+1)</item>
		<item>Calcula (vBB, vBB+1) % (vCC, vCC+1) y almacena el resultado en el par de registros vAA, vAA+1. Todos los valores son dobles (punto flotante).\n(vAA, vAA+1) = (vBB, vBB+1) % (vCC, vCC+1)</item>
		<item>Calcula vA + vB y almacena el resultado en el registro vA. Todos los valores son enteros.\nvA = vA + vB</item>
		<item>Calcula vA - vB y almacena el resultado en el registro vA. Todos los valores son enteros.\nvA = vA - vB</item>
		<item>Calcula vA * vB y almacena el resultado en el registro vA. Todos los valores son enteros.\nvA = vA * vB</item>
		<item>Calcula vA/vB y almacena el resultado en el registro vA. Todos los valores son enteros.\nvA = vA / vB</item>
		<item>Calcula vA % vB y almacena el resultado en el registro vA. Todos los valores son enteros.\nvA = vA % vB</item>
		<item>Calcula vA y vB (Y lógico) y almacena el resultado en el registro vA. Todos los valores son enteros.\nvA = vA y vB</item>
		<item>Calcula vA | vB (OR lógico) y almacena el resultado en el registro vA. Todos los valores son enteros.\nvA = vA | vB</item>
		<item>Calcula vA ^ vB (OR exclusivo) y almacena el resultado en el registro vA. Todos los valores son enteros.\nvA = vA ^vB</item>
		<item>Desplaza vA hacia la izquierda el número de bits especificado por vB y almacena el resultado en el registro vA. Todos los valores son enteros.\nvA = vA &lt;&lt; vB</item>
		<item>Desplaza vA hacia la derecha el número de bits especificado por vB y almacena el resultado en el registro vA. Todos los valores son enteros.\nvA = vA >> vB</item>
		<item>Desplaza vA sin conservar su signo hacia la derecha el número de bits especificado por vB y almacena el resultado en el registro vA. Todos los valores son enteros.\nvA = vA >>> vB</item>
		<item>Calcula (vA, vA+1) + (vB, vB+1) y almacena el resultado en el par de registros vA, vA+1. Todos los valores son largos (enteros).\n(vA, vA+1) = (vA, vA+1) + (vB, vB+1)</item>
		<item>Calcula (vA, vA+1) - (vB, vB+1) y almacena el resultado en un par de registros vA, vA+1. Todos los valores son largos (enteros).\n(vA, vA+1) = (vA, vA+1) - (vB, vB+1)</item>
		<item>Calcula (vA, vA+1) * (vB, vB+1) y almacena el resultado en el par de registros vA, vA+1. Todos los valores son largos (enteros).\n(vA, vA+1) = (vA, vA+1) * (vB, vB+1)</item>
		<item>Calcula (vA, vA+1) / (vB, vB+1) y almacena el resultado en el par de registros vA, vA+1. Todos los valores son largos (enteros).\n(vA, vA+1) = (vA, vA+1) / (vB, vB+1)</item>
		<item>Calcula (vA, vA+1) % (vB, vB+1) y almacena el resultado en el par de registros vA, vA+1. Todos los valores son largos (enteros).\n(vA, vA+1) = (vA, vA+1) % (vB, vB+1)</item>
		<item>Calcula (vA, vA+1) y (vB, vB+1) (Y lógico) y almacena el resultado en el par de registros vA, vA+1. Todos los valores son largos (enteros).\n(vA, vA+1) = (vA, vA+1) y (vB, vB+1)</item>
		<item>Calcula (vA, vA+1) | (vB, vB+1) (OR lógico) y almacena el resultado en un par de registros vA, vA+1. Todos los valores son largos (enteros).\n(vA, vA+1) = (vA, vA+1) | (vB, vB+1)</item>
		<item>Calcula (vA, vA+1) y (vB, vB+1) (OR exclusivo) y almacena el resultado en el par de registros vA, vA+1. Todos los valores son largos (enteros).\n(vA, vA+1) = (vA, vA+1) ^ (vB, vB+1)</item>
		<item>Desplaza vA, vA+1 hacia la izquierda el número de bits especificado por vB y almacena el resultado en el par de registros vA, vA+1. Todos los valores son largos (enteros).\n(vA, vA+1) = (vA, vA+1) &lt;&lt; vB</item>
		<item>Desplaza vA, vA+1 hacia la derecha el número de bits especificado por vB y almacena el resultado en el par de registros vA, vA+1. Todos los valores son largos (enteros).\n(vA, vA+1) = (vA, vA+1) >> vB</item>
		<item>Desplaza vA, vA+1 hacia la derecha sin conservar el signo por el número de dígitos especificado por vB y almacena el resultado en un par de registros vA, vA+1. Todos los valores son largos (enteros).\n(vA, vA+1) = (vA, vA+1) >>> vB</item>
		<item>Calcula vA + vB y almacena el resultado en el registro vA. Todos los valores son flotantes.\nvA = vA + vB</item>
		<item>Calcula vA - vB y almacena el resultado en el registro vA. Todos los valores son flotantes.\nvA = vA - vB</item>
		<item>Calcula vA * vB y almacena el resultado en el registro vA. Todos los valores son flotantes.\nvA = vA * vB</item>
		<item>Calcula vA/vB y almacena el resultado en el registro vA. Todos los valores son flotantes.\nvA = vA / vB</item>
		<item>Calcula vA % vB y almacena el resultado en el registro vA. Todos los valores son flotantes.\nvA = vA % vB</item>
		<item>Calcula (vA, vA+1) + (vB, vB+1) y almacena el resultado en el par de registros vA, vA+1. Todos los valores son dobles (punto flotante).\n(vA, vA+1) = (vA, vA+1) + (vB, vB+1)</item>
		<item>Calcula (vA, vA+1) - (vB, vB+1) y almacena el resultado en un par de registros vA, vA+1. Todos los valores son dobles (punto flotante).\n(vA, vA+1) = (vA, vA+1) - (vB, vB+1)</item>
		<item>Calcula (vA, vA+1) * (vB, vB+1) y almacena el resultado en el par de registros vA, vA+1. Todos los valores son dobles (punto flotante).\n(vA, vA+1) = (vA, vA+1) * (vB, vB+1)</item>
		<item>Calcula (vA, vA+1) / (vB, vB+1) y almacena el resultado en el par de registros vA, vA+1. Todos los valores son dobles (punto flotante).\n(vA, vA+1) = (vA, vA+1) / (vB, vB+1)</item>
		<item>Calcula (vA, vA+1) % (vB, vB+1) y almacena el resultado en el par de registros vA, vA+1. Todos los valores son dobles (punto flotante).\n(vA, vA+1) = (vA, vA+1) % (vB, vB+1)</item>
		<item>Calcula vB + 0xFFFF y almacena el resultado en el registro vA. Todos los valores son enteros.\nvA = vB + 0xFFFF</item>
		<item>Calcula 0xFFFF - vB y almacena el resultado en el registro vA. Todos los valores son enteros.\nvA = 0xFFFF - vB</item>
		<item>Calcula vB * 0xFFFF y almacena el resultado en el registro vA. Todos los valores son enteros.\nvA = vB * 0xFFFF</item>
		<item>Calcula vB/0xFFFF y almacena el resultado en el registro vA. Todos los valores son enteros.\nvA = vB / 0xFFFF</item>
		<item>Calcula vB % 0xFFFF y almacena el resultado en el registro vA. Todos los valores son enteros.\nvA = vB % 0xFFFF</item>
		<item>Calcula vB y 0xFFFF (Y lógico) y almacena el resultado en el registro vA. Todos los valores son enteros.\nvA = vB y 0xFFFF</item>
		<item>Calcula vB | 0xFFFF (OR lógico) y almacena el resultado en el registro vA. Todos los valores son enteros.\nvA = vB | 0xFFFF</item>
		<item>Calcula vB ^ 0xFFFF (OR exclusivo) y almacena el resultado en el registro vA. Todos los valores son enteros.\nvA = vB ^ 0xFFFF</item>
		<item>Calcula vBB + 0xFF y almacena el resultado en el registro vAA. Todos los valores son enteros.\nvAA = vBB + 0xFF</item>
		<item>Calcula 0xFF - vBB y almacena el resultado en el registro vAA. Todos los valores son enteros.\nvAA = 0xFF - vBB</item>
		<item>Calcula vBB * 0xFF y almacena el resultado en el registro vAA. Todos los valores son enteros.\nvAA = vBB * 0xFF</item>
		<item>Calcula vBB/0xFF y almacena el resultado en el registro vAA. Todos los valores son enteros.\nvAA = vBB / 0xFF</item>
		<item>Calcula vBB % 0xFF y almacena el resultado en el registro vAA. Todos los valores son enteros.\nvAA = vBB % 0xFF</item>
		<item>Calcula vBB y 0xFF (Y lógico) y almacena el resultado en el registro vAA. Todos los valores son enteros.\nvAA = vBB y 0xFF</item>
		<item>Calcula vBB | 0xFF (OR lógico) y almacena el resultado en el registro vAA. Todos los valores son enteros.\nvAA = vBB | 0xFF</item>
		<item>Calcula vBB ^ 0xFF (OR exclusivo) y almacena el resultado en el registro vAA. Todos los valores son enteros.\nvAA = vBB ^ 0xFF</item>
		<item>Desplaza vBB hacia la izquierda el número de bits especificado por 0xFF y almacena el resultado en el registro vAA. Todos los valores son enteros.\nvAA = vBB &lt;&lt; 0xFF</item>
		<item>Desplaza vBB hacia la derecha el número de bits especificado por 0xFF y almacena el resultado en el registro vAA. Todos los valores son enteros.\nvAA = vBB >> 0xFF</item>
		<item>Signally desplaza vBB hacia la derecha según el número de bits especificado por 0xFF y almacena el resultado en el registro vAA. Todos los valores son enteros.\nvAA = vBB >>> 0xFF</item>
		<item>Llama (ejecuta) un método de firma polimórfico con parámetros. Presente en archivos Dex desde la versión 038.</item>
		<item>Llama (ejecuta) un método de firma polimórfico con parámetros, pero los parámetros deben estar contenidos en registros numerados secuencialmente. Presente en archivos Dex desde la versión 038.</item>
		<item>Permite (inicia) llamar a un sitio con parámetros. Presente en archivos Dex desde la versión 038.</item>
		<item>Permite (inicia) llamar a un sitio con parámetros, pero los parámetros deben estar contenidos en registros con números en orden. Presente en archivos Dex desde la versión 038.</item>
		<item>Coloca una referencia a un identificador de método en el registro vAA. Presente en archivos Dex desde la versión 039.</item>
		<item>Coloca una referencia al prototipo del método en el registro vAA. Presente en archivos Dex desde la versión 039.</item>
	</string-array>
    <string-array name="jadx_sets">
		<item>Respaldo</item>
		<item>Deobfuscación</item>
		<item>Escapar Unicode</item>
		<item>Mostrar código inconsistente</item>
	</string-array>
	<string-array name="copy_variants">
		<item>Renombrar</item>
		<item>Solo cambiar el nombre de los archivos</item>
		<item>Reemplazar</item>
		<item>Omitir</item>
	</string-array>
	<string-array name="menu_pos">
		<item>Izquierda</item>
		<item>Derecha</item>
	</string-array>
	<string-array name="sort">
		<item>Nombre</item>
		<item>Nombre inverso</item>
		<item>Tipo</item>
		<item>Tipo inverso</item>
		<item>Tamaño</item>
		<item>Tamaño inverso</item>
		<item>Hora</item>
		<item>Tiempo inverso</item>
	</string-array>
	<string-array name="format">
		<item>@string/jks</item>
		<item>@string/pkcs12</item>
		<item>@string/bks</item>
		<item>@string/pk8</item>
	</string-array>
	<string-array name="resDecodeMode">
		<item>No descompilar</item>
		<item>Descompilar al directorio principal</item>
		<item>Descompilar en un directorio distinto</item>
        <item>Try to merge packages</item>
	</string-array>
	<string-array name="converter_items">
		<item>Texto &lt;-> Base64</item>
		<item>Texto &lt;-> Unicode</item>
		<item>Texto &lt;-> Codificación URL</item>
		<item>Texto &lt;-> MD5</item>
		<item>Texto &lt;-> SHA-1</item>
		<item>Texto &lt;-> SHA-224</item>
		<item>Texto &lt;-> SHA-256</item>
		<item>Texto &lt;-> SHA-384</item>
		<item>Texto &lt;-> SHA-512</item>
		<item>Texto &lt;-> Array (UTF-8)</item>
		<item>Texto &lt;-> Array (UTF-16)</item>
		<item>Texto &lt;-> Array (UTF-16LE)</item>
		<item>Texto &lt;-> Array (UTF-16BE)</item>
		<item>Texto &lt;-> Array (US-ASCII)</item>
		<item>Texto &lt;-> Array (ISO-8859-1)</item>
		<item>Texto &lt;-> Array (CP1251)</item>
		<item>Decimal &lt;-> Binario</item>
		<item>Decimal &lt;-> Octal</item>
		<item>Decimal &lt;-> Hex</item>
		<item>Decimal &lt;-> Hex (0x0)</item>
		<item>Decimal &lt;-> Hex (0x00000000)</item>
		<item>Float &lt;-> Binary</item>
		<item>Float &lt;-> Octal</item>
		<item>Float &lt;-> Hex</item>
		<item>Float &lt;-> Hex (0x0)</item>
		<item>Float &lt;-> Hex (0x00000000)</item>
		<item>Color &lt;-> Smali</item>
		<item>Color &lt;-> Decimal</item>
		<item>Color &lt;-> A,R,G,B</item>
        <item>Date &lt;-> Milliseconds</item>
		<item>Date &lt;-> Hex</item>
	</string-array>
	<string-array name="installLocation">
		<item>Sin definir</item>
		<item>Automático</item>
		<item>Memoria Interna</item>
		<item>Memoria Externa</item>
	</string-array>
	<string-array name="auto_save_variants">
		<item>Desactivado</item>
		<item>15 segundos</item>
		<item>30 segundos</item>
		<item>1 minuto</item>
		<item>5 minutos</item>
	</string-array>
	<string-array name="to_vector_values">
		<item>Imagen adaptada (calidad inferior)</item>
		<item>Imagen de alta calidad (tamaño mayor)</item>
		<item>Convert to SVG</item>
	</string-array>
	<string-array name="backup_values">
		<item>Ajustes</item>
		<item>Marcadores</item>
		<item>Historial</item>
		<item>Diccionarios</item>
	</string-array>
	<string-array name="editor_themes">
		<item>Predeterminado</item>
		<item>Nuevo</item>
	</string-array>
	<string-array name="bing_translator_codes">
		<item>auto-detect</item>
		<item>az</item>
		<item>sq</item>
		<item>en</item>
		<item>ar</item>
		<item>hy</item>
		<item>af</item>
		<item>bn</item>
		<item>bg</item>
		<item>bs</item>
		<item>cy</item>
		<item>hu</item>
		<item>vi</item>
		<item>ht</item>
		<item>nl</item>
		<item>el</item>
		<item>gu</item>
		<item>da</item>
		<item>he</item>
		<item>id</item>
		<item>ga</item>
		<item>is</item>
		<item>es</item>
		<item>it</item>
		<item>kk</item>
		<item>kn</item>
		<item>yue</item>
		<item>ca</item>
		<item>otq</item>
		<item>zh-Hant</item>
		<item>zh-Hans</item>
		<item>ko</item>
		<item>lv</item>
		<item>lt</item>
		<item>mg</item>
		<item>ms</item>
		<item>ml</item>
		<item>mt</item>
		<item>mi</item>
		<item>mr</item>
		<item>de</item>
		<item>ne</item>
		<item>nb</item>
		<item>or</item>
		<item>pa</item>
		<item>fa</item>
		<item>pl</item>
		<item>pt</item>
		<item>pt-PT</item>
		<item>ro</item>
		<item>ru</item>
		<item>sm</item>
		<item>sr-Cyrl</item>
		<item>sr-Latn</item>
		<item>sk</item>
		<item>sl</item>
		<item>sw</item>
		<item>ty</item>
		<item>th</item>
		<item>ta</item>
		<item>te</item>
		<item>to</item>
		<item>tr</item>
		<item>uk</item>
		<item>ur</item>
		<item>fj</item>
		<item>fil</item>
		<item>fi</item>
		<item>fr</item>
		<item>hi</item>
		<item>mww</item>
		<item>hr</item>
		<item>cs</item>
		<item>sv</item>
		<item>et</item>
		<item>yua</item>
		<item>ja</item>
		<item>am</item>
		<item>as</item>
		<item>prs</item>
		<item>fr-CA</item>
		<item>iu</item>
		<item>km</item>
		<item>tlh-Latn</item>
		<item>ku</item>
		<item>kmr</item>
		<item>lo</item>
		<item>my</item>
		<item>ps</item>
		<item>ti</item>
	</string-array>
	<string-array name="bing_translator_names">
		<item>Automático</item>
		<item>Azerbaijani (Latin)</item>
		<item>Albanian</item>
		<item>English</item>
		<item>Arabic</item>
		<item>Armenian</item>
		<item>Afrikaans</item>
		<item>Bengali</item>
		<item>Bulgarian</item>
		<item>Bosnian</item>
		<item>Welsh</item>
		<item>Hungarian</item>
		<item>Vietnamese</item>
		<item>Haitian Creole</item>
		<item>Dutch</item>
		<item>Greek</item>
		<item>Gujarati</item>
		<item>Danish</item>
		<item>Hebrew</item>
		<item>Indonesian</item>
		<item>Irish</item>
		<item>Icelandic</item>
		<item>Spanish</item>
		<item>Italian</item>
		<item>Kazakh</item>
		<item>Kannada</item>
		<item>Cantonese Traditional</item>
		<item>Catalan</item>
		<item>Keretarian Otomi</item>
		<item>Traditional Chinese</item>
		<item>Chinese Simplified</item>
		<item>Korean</item>
		<item>Latvian</item>
		<item>Lithuanian</item>
		<item>Malagasy</item>
		<item>Malay</item>
		<item>Malayalam</item>
		<item>Maltese</item>
		<item>Maori</item>
		<item>Marathi</item>
		<item>German</item>
		<item>Nepali</item>
		<item>Norwegian</item>
		<item>Oriya</item>
		<item>Punjabi</item>
		<item>Persian</item>
		<item>Polish</item>
		<item>Portuguese (Brazil)</item>
		<item>Portuguese (Portugal)</item>
		<item>Romanian</item>
		<item>Russian</item>
		<item>Samoa</item>
		<item>Serbian (Cyrillic)</item>
		<item>Serbian (Latin)</item>
		<item>Slovak</item>
		<item>Slovenian</item>
		<item>Swahili</item>
		<item>Tahiti</item>
		<item>Thai</item>
		<item>Tamil</item>
		<item>Telugu</item>
		<item>Tonga</item>
		<item>Turkish</item>
		<item>Ukrainian</item>
		<item>Urdu</item>
		<item>Fiji</item>
		<item>Filipino</item>
		<item>Finnish</item>
		<item>French</item>
		<item>Hindi</item>
		<item>Hmong Dhow</item>
		<item>Croatian</item>
		<item>Czech</item>
		<item>Swedish</item>
		<item>Estonian</item>
		<item>Yucatec Maya</item>
		<item>Japanese</item>
		<item>Amharic</item>
		<item>Assamese</item>
		<item>Dari</item>
		<item>French (Canada)</item>
		<item>Inuktitut</item>
		<item>Khmer</item>
		<item>Klingon (Latin)</item>
		<item>Kurdish (Central)</item>
		<item>Kurdish (Northern)</item>
		<item>Lao</item>
		<item>Myanmar (Burmese)</item>
		<item>Pashto</item>
		<item>Tigrinya</item>
	</string-array>
	<string-array name="google_translator_codes">
		<item>auto</item>
		<item>af</item>
		<item>sq</item>
		<item>am</item>
		<item>ar</item>
		<item>hy</item>
		<item>az</item>
		<item>eu</item>
		<item>be</item>
		<item>bn</item>
		<item>bs</item>
		<item>bg</item>
		<item>ca</item>
		<item>ceb</item>
		<item>ny</item>
		<item>zh-cn</item>
		<item>zh-tw</item>
		<item>co</item>
		<item>hr</item>
		<item>cs</item>
		<item>da</item>
		<item>nl</item>
		<item>en</item>
		<item>eo</item>
		<item>et</item>
		<item>tl</item>
		<item>fi</item>
		<item>fr</item>
		<item>fy</item>
		<item>gl</item>
		<item>ka</item>
		<item>de</item>
		<item>el</item>
		<item>gu</item>
		<item>ht</item>
		<item>ha</item>
		<item>haw</item>
		<item>iw</item>
		<item>hi</item>
		<item>hmn</item>
		<item>hu</item>
		<item>is</item>
		<item>ig</item>
		<item>id</item>
		<item>ga</item>
		<item>it</item>
		<item>ja</item>
		<item>jw</item>
		<item>kn</item>
		<item>kk</item>
		<item>km</item>
		<item>ko</item>
		<item>ku</item>
		<item>ky</item>
		<item>lo</item>
		<item>la</item>
		<item>lv</item>
		<item>lt</item>
		<item>lb</item>
		<item>mk</item>
		<item>mg</item>
		<item>ms</item>
		<item>ml</item>
		<item>mt</item>
		<item>mi</item>
		<item>mr</item>
		<item>mn</item>
		<item>my</item>
		<item>ne</item>
		<item>no</item>
		<item>ps</item>
		<item>fa</item>
		<item>pl</item>
		<item>pt</item>
		<item>ma</item>
		<item>ro</item>
		<item>ru</item>
		<item>sm</item>
		<item>gd</item>
		<item>sr</item>
		<item>st</item>
		<item>sn</item>
		<item>sd</item>
		<item>si</item>
		<item>sk</item>
		<item>sl</item>
		<item>so</item>
		<item>es</item>
		<item>su</item>
		<item>sw</item>
		<item>sv</item>
		<item>tg</item>
		<item>ta</item>
		<item>te</item>
		<item>th</item>
		<item>tr</item>
		<item>uk</item>
		<item>ur</item>
		<item>uz</item>
		<item>vi</item>
		<item>cy</item>
		<item>xh</item>
		<item>yi</item>
		<item>yo</item>
		<item>zu</item>
		<item>or</item>
		<item>pa</item>
		<item>rw</item>
		<item>tt</item>
		<item>tk</item>
		<item>ug</item>
	</string-array>
	<string-array name="google_translator_names">
		<item>Automático</item>
		<item>Afrikaans</item>
		<item>Albanian</item>
		<item>Amharic</item>
		<item>Arabic</item>
		<item>Armenian</item>
		<item>Azerbaijani</item>
		<item>Basque</item>
		<item>Belarusian</item>
		<item>Bengali</item>
		<item>Bosnian</item>
		<item>Bulgarian</item>
		<item>Catalan</item>
		<item>Cebuano</item>
		<item>Chichewa</item>
		<item>Chinese Simplified</item>
		<item>Chinese Traditional</item>
		<item>Corsican</item>
		<item>Croatian</item>
		<item>Czech</item>
		<item>Danish</item>
		<item>Dutch</item>
		<item>English</item>
		<item>Esperanto</item>
		<item>Estonian</item>
		<item>Filipino</item>
		<item>Finnish</item>
		<item>French</item>
		<item>Frisian</item>
		<item>Galician</item>
		<item>Georgian</item>
		<item>German</item>
		<item>Greek</item>
		<item>Gujarati</item>
		<item>Haitian Creole</item>
		<item>Hausa</item>
		<item>Hawaiian</item>
		<item>Hebrew</item>
		<item>Hindi</item>
		<item>Hmong</item>
		<item>Hungarian</item>
		<item>Icelandic</item>
		<item>Igbo</item>
		<item>Indonesian</item>
		<item>Irish</item>
		<item>Italian</item>
		<item>Japanese</item>
		<item>Javanese</item>
		<item>Kannada</item>
		<item>Kazakh</item>
		<item>Khmer</item>
		<item>Korean</item>
		<item>Kurdish (Kurmanji)</item>
		<item>Kyrgyz</item>
		<item>Lao</item>
		<item>Latin</item>
		<item>Latvian</item>
		<item>Lithuanian</item>
		<item>Luxembourgish</item>
		<item>Macedonian</item>
		<item>Malagasy</item>
		<item>Malay</item>
		<item>Malayalam</item>
		<item>Maltese</item>
		<item>Maori</item>
		<item>Marathi</item>
		<item>Mongolian</item>
		<item>Myanmar (Burmese)</item>
		<item>Nepali</item>
		<item>Norwegian</item>
		<item>Pashto</item>
		<item>Persian</item>
		<item>Polish</item>
		<item>Portuguese</item>
		<item>Punjabi</item>
		<item>Romanian</item>
		<item>Russian</item>
		<item>Samoan</item>
		<item>Scots Gaelic</item>
		<item>Serbian</item>
		<item>Sesotho</item>
		<item>Shona</item>
		<item>Sindhi</item>
		<item>Sinhala</item>
		<item>Slovak</item>
		<item>Slovenian</item>
		<item>Somali</item>
		<item>Spanish</item>
		<item>Sundanese</item>
		<item>Swahili</item>
		<item>Swedish</item>
		<item>Tajik</item>
		<item>Tamil</item>
		<item>Telugu</item>
		<item>Thai</item>
		<item>Turkish</item>
		<item>Ukrainian</item>
		<item>Urdu</item>
		<item>Uzbek</item>
		<item>Vietnamese</item>
		<item>Welsh</item>
		<item>Xhosa</item>
		<item>Yiddish</item>
		<item>Yoruba</item>
		<item>Zulu</item>
		<item>Oriya</item>
		<item>Punjabi</item>
		<item>Rwanda</item>
		<item>Tatar</item>
		<item>Turkmen</item>
		<item>Uigur</item>
	</string-array>
	<string-array name="yandex_translator_codes">
		<item>auto</item>
		<item>af</item>
		<item>sq</item>
		<item>am</item>
		<item>ar</item>
		<item>hy</item>
		<item>az</item>
		<item>ba</item>
		<item>eu</item>
		<item>be</item>
		<item>bn</item>
		<item>bs</item>
		<item>bg</item>
		<item>my</item>
		<item>ca</item>
		<item>ceb</item>
		<item>zh</item>
		<item>cv</item>
		<item>hr</item>
		<item>cs</item>
		<item>da</item>
		<item>nl</item>
		<item>sjn</item>
		<item>emj</item>
		<item>en</item>
		<item>eo</item>
		<item>et</item>
		<item>fi</item>
		<item>fr</item>
		<item>gl</item>
		<item>ka</item>
		<item>de</item>
		<item>el</item>
		<item>gu</item>
		<item>ht</item>
		<item>he</item>
		<item>mrj</item>
		<item>hi</item>
		<item>hu</item>
		<item>is</item>
		<item>id</item>
		<item>ga</item>
		<item>it</item>
		<item>ja</item>
		<item>jv</item>
		<item>kn</item>
		<item>kk</item>
		<item>kazlat</item>
		<item>km</item>
		<item>ko</item>
		<item>ky</item>
		<item>lo</item>
		<item>la</item>
		<item>lv</item>
		<item>lt</item>
		<item>lb</item>
		<item>mk</item>
		<item>mg</item>
		<item>ms</item>
		<item>ml</item>
		<item>mt</item>
		<item>mi</item>
		<item>mr</item>
		<item>mhr</item>
		<item>mn</item>
		<item>ne</item>
		<item>no</item>
		<item>pap</item>
		<item>fa</item>
		<item>pl</item>
		<item>pt</item>
		<item>pa</item>
		<item>ro</item>
		<item>ru</item>
		<item>gd</item>
		<item>sr</item>
		<item>si</item>
		<item>sk</item>
		<item>sl</item>
		<item>es</item>
		<item>su</item>
		<item>sw</item>
		<item>sv</item>
		<item>tl</item>
		<item>tg</item>
		<item>ta</item>
		<item>tt</item>
		<item>te</item>
		<item>th</item>
		<item>tr</item>
		<item>udm</item>
		<item>uk</item>
		<item>ur</item>
		<item>uz</item>
		<item>uzbcyr</item>
		<item>vi</item>
		<item>cy</item>
		<item>xh</item>
		<item>sah</item>
		<item>yi</item>
	</string-array>
	<string-array name="yandex_translator_names">
		<item>Automático</item>
		<item>Afrikaans</item>
		<item>Albanian</item>
		<item>Amharic</item>
		<item>Arabic</item>
		<item>Armenian</item>
		<item>Azerbaijani</item>
		<item>Bashkir</item>
		<item>Basque</item>
		<item>Belarusian</item>
		<item>Bengali</item>
		<item>Bosnian</item>
		<item>Bulgarian</item>
		<item>Burmese</item>
		<item>Catalan</item>
		<item>Cebuano</item>
		<item>Chinese</item>
		<item>Chuvash</item>
		<item>Croatian</item>
		<item>Czech</item>
		<item>Danish</item>
		<item>Dutch</item>
		<item>Elvish (Sindarin)</item>
		<item>Emoji</item>
		<item>English</item>
		<item>Esperanto</item>
		<item>Estonian</item>
		<item>Finnish</item>
		<item>French</item>
		<item>Galician</item>
		<item>Georgian</item>
		<item>German</item>
		<item>Greek</item>
		<item>Gujarati</item>
		<item>Haitian</item>
		<item>Hebrew</item>
		<item>Hill Mari</item>
		<item>Hindi</item>
		<item>Hungarian</item>
		<item>Icelandic</item>
		<item>Indonesian</item>
		<item>Irish</item>
		<item>Italian</item>
		<item>Japanese</item>
		<item>Javanese</item>
		<item>Kannada</item>
		<item>Kazakh</item>
		<item>Kazakh (Latin)</item>
		<item>Khmer</item>
		<item>Korean</item>
		<item>Kyrgyz</item>
		<item>Lao</item>
		<item>Latin</item>
		<item>Latvian</item>
		<item>Lithuanian</item>
		<item>Luxembourgish</item>
		<item>Macedonian</item>
		<item>Malagasy</item>
		<item>Malay</item>
		<item>Malayalam</item>
		<item>Maltese</item>
		<item>Maori</item>
		<item>Marathi</item>
		<item>Mari</item>
		<item>Mongolian</item>
		<item>Nepali</item>
		<item>Norwegian</item>
		<item>Papiamento</item>
		<item>Persian</item>
		<item>Polish</item>
		<item>Portuguese</item>
		<item>Punjabi</item>
		<item>Romanian</item>
		<item>Russian</item>
		<item>Scottish Gaelic</item>
		<item>Serbian</item>
		<item>Sinhalese</item>
		<item>Slovak</item>
		<item>Slovenian</item>
		<item>Spanish</item>
		<item>Sundanese</item>
		<item>Swahili</item>
		<item>Swedish</item>
		<item>Tagalog</item>
		<item>Tajik</item>
		<item>Tamil</item>
		<item>Tatar</item>
		<item>Telugu</item>
		<item>Thai</item>
		<item>Turkish</item>
		<item>Udmurt</item>
		<item>Ukrainian</item>
		<item>Urdu</item>
		<item>Uzbek</item>
		<item>Uzbek (Cyrillic)</item>
		<item>Vietnamese</item>
		<item>Welsh</item>
		<item>Xhosa</item>
		<item>Yakut</item>
		<item>Yiddish</item>
	</string-array>
</resources>